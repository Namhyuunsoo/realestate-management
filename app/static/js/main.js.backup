/* -----------------------------------------
 * main.js  (로그인 화면 + 네이버 지도 + 필터/리스트 + 상단 가로 필터)
 * -----------------------------------------
 * - UI: 로그인 스크린 / 앱 화면 전환
 * - 사용자: 세션(/api/me) + 임시 이메일(localStorage)
 * - 지도: 네이버 지도 SDK, 마커 표시
 * - 데이터: /api/listings (X-User 헤더)
 * - 필터: 고객 기본 필터 + 상단 필터(우선) + (기존 좌측 필터 유지)
 * - 정렬/태그/거리 계산
 * - 패널: 고객 상세/신규등록(2차 사이드바), 전체보기 패널(부분 오버레이)
 * - 색인(핀): 준비(로컬스토리지) - 다음 단계에서 구현
 * ----------------------------------------- */

/*******************************
 * ===== main.js - 나머지 기능들 =====
 *******************************/
// 전역 변수들은 globals.js에서 이미 선언됨
let BRIEFING_FILTERS = {
  normal: true,
  pending: true,
  completed: true,
  onhold: true
};

// 유틸리티 함수들은 utils.js에서 이미 정의됨

// 유틸리티 함수들은 utils.js에서 이미 정의됨

/**************************************
 * ===== 브리핑 상태 관리 =====
 **************************************/
function loadBriefingStates(customerId) {
  if (!customerId) {
    CURRENT_BRIEFING_STATES = {};
    return;
  }
  
  try {
    const stored = localStorage.getItem(`briefing_${customerId}`);
    CURRENT_BRIEFING_STATES = stored ? JSON.parse(stored) : {};
  } catch (e) {
    console.error('브리핑 상태 로드 실패:', e);
    CURRENT_BRIEFING_STATES = {};
  }
}

function saveBriefingStates(customerId) {
  if (!customerId) return;
  
  try {
    localStorage.setItem(`briefing_${customerId}`, JSON.stringify(CURRENT_BRIEFING_STATES));
  } catch (e) {
    console.error('브리핑 상태 저장 실패:', e);
  }
}

function getBriefingStatus(listingId) {
  return CURRENT_BRIEFING_STATES[listingId] || BRIEFING_STATUS.NORMAL;
}

function setBriefingStatus(listingId, status) {
  if (status === BRIEFING_STATUS.NORMAL) {
    delete CURRENT_BRIEFING_STATES[listingId];
  } else {
    CURRENT_BRIEFING_STATES[listingId] = status;
  }
  
  // 현재 선택된 고객이 있으면 저장
  if (window.selectedCustomer && window.selectedCustomer.id) {
    saveBriefingStates(window.selectedCustomer.id);
  }
  
  // UI 업데이트
  updateBriefingStatusUI(listingId, status);
  updateMarkerBriefingStatus(listingId, status);
}

function updateBriefingStatusUI(listingId, status) {
  // 매물리스트 업데이트
  const listItem = document.querySelector(`#listingList li[data-id="${listingId}"]`);
  if (listItem) {
    updateListingItemBriefingStatus(listItem, status);
  }
  
  // 클러스터 목록 업데이트
  const clusterItem = document.querySelector(`#clusterItemList li[data-id="${listingId}"]`);
  if (clusterItem) {
    updateListingItemBriefingStatus(clusterItem, status);
  }
  
  // 매물 상세 정보 업데이트
  if (SELECTED_MARKER_ID === listingId) {
    updateDetailPanelBriefingStatus(status);
  }
}

function updateListingItemBriefingStatus(listItem, status) {
  let indicator = listItem.querySelector('.briefing-status-indicator');
  
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.className = 'briefing-status-indicator';
    listItem.style.position = 'relative';
    listItem.appendChild(indicator);
  }
  
  // 기존 클래스 제거
  indicator.className = 'briefing-status-indicator';
  indicator.classList.add(`briefing-${status}`);
  
  // 클릭 이벤트
  indicator.onclick = (e) => {
    e.stopPropagation();
    cycleBriefingStatus(listItem.dataset.id);
  };
}

function updateDetailPanelBriefingStatus(status) {
  const detailPanel = document.getElementById('viewListingDetail');
  if (!detailPanel) return;
  
  let statusElement = detailPanel.querySelector('.listing-detail-briefing-status');
  
  if (!statusElement) {
    // 주소 정보 다음에 상태 표시 추가
    const addrElement = detailPanel.querySelector('.detail-row');
    if (addrElement) {
      statusElement = document.createElement('span');
      statusElement.className = 'listing-detail-briefing-status';
      statusElement.onclick = () => cycleBriefingStatus(SELECTED_MARKER_ID);
      addrElement.appendChild(statusElement);
    }
  }
  
  if (statusElement) {
    statusElement.className = 'listing-detail-briefing-status';
    statusElement.classList.add(`briefing-${status}`);
    statusElement.textContent = getBriefingStatusText(status);
  }
}
function updateMarkerBriefingStatus(listingId, status) {
  const marker = MARKERS.find(m => m._listingId === listingId);
  if (!marker) return;
  
  const color = STATUS_COLORS[LISTINGS.find(x => x.id === listingId)?.status_raw] || "#007AFF";
  const isActive = (marker._listingId === SELECTED_MARKER_ID);
  
  marker.setIcon({ 
    content: createMarkerIcon(color, isActive, status)
  });
  
  // 클러스터 버블도 업데이트
  updateClusterBubbles();
}

function updateClusterBubbles() {
  if (!CLUSTERER || !CLUSTERER._clusters) return;
  
  CLUSTERER._clusters.forEach(cluster => {
    const clusterMarker = cluster._clusterMarker;
    if (!clusterMarker || !cluster.getClusterMember) return;
    
    const clusterMembers = cluster.getClusterMember();
    if (!clusterMembers) return;
    
    const count = clusterMembers.length;
    let cls = "cluster-small";
    if (count >= 50)      cls = "cluster-big";
    else if (count >= 10) cls = "cluster-mid";

    // 클러스터 내 매물들의 브리핑 상태 분석
    const briefingStats = {
      normal: 0,
      pending: 0,
      completed: 0,
      onhold: 0
    };
    
    clusterMembers.forEach(marker => {
      if (marker && marker._listingId) {
        const status = getBriefingStatus(marker._listingId);
        briefingStats[status]++;
      }
    });
    
    // 브리핑 상태에 따른 버블 스타일 결정
    let bubbleStyle = "";
    let bubbleContent = count;
    
    // 브리핑 상태가 있는 매물이 있으면 색상 변경
    const hasBriefingItems = briefingStats.pending > 0 || briefingStats.completed > 0 || briefingStats.onhold > 0;
    
    if (hasBriefingItems) {
      // 주요 브리핑 상태 결정 (우선순위: 완료 > 예정 > 보류)
      let primaryStatus = BRIEFING_STATUS.NORMAL;
      if (briefingStats.completed > 0) {
        primaryStatus = BRIEFING_STATUS.COMPLETED;
      } else if (briefingStats.pending > 0) {
        primaryStatus = BRIEFING_STATUS.PENDING;
      } else if (briefingStats.onhold > 0) {
        primaryStatus = BRIEFING_STATUS.ONHOLD;
      }
      
      // 브리핑 상태별 색상
      const statusColors = {
        [BRIEFING_STATUS.NORMAL]: '#007AFF',
        [BRIEFING_STATUS.PENDING]: '#FF3B30',
        [BRIEFING_STATUS.COMPLETED]: '#34C759',
        [BRIEFING_STATUS.ONHOLD]: '#AF52DE'
      };
      
      bubbleStyle = `background-color: ${statusColors[primaryStatus]} !important; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);`;
    }

    const bubbleHtml = `<div class="cluster-bubble ${cls}" style="${bubbleStyle}">${bubbleContent}</div>`;
    const wrapper = clusterMarker.getElement();
    if (wrapper) {
      wrapper.innerHTML = bubbleHtml;
    }
  });
}

function cycleBriefingStatus(listingId) {
  const currentStatus = getBriefingStatus(listingId);
  const statusOrder = [BRIEFING_STATUS.NORMAL, BRIEFING_STATUS.PENDING, BRIEFING_STATUS.COMPLETED, BRIEFING_STATUS.ONHOLD];
  const currentIndex = statusOrder.indexOf(currentStatus);
  const nextIndex = (currentIndex + 1) % statusOrder.length;
  const nextStatus = statusOrder[nextIndex];
  
  setBriefingStatus(listingId, nextStatus);
}

function getBriefingStatusText(status) {
  const statusTexts = {
    [BRIEFING_STATUS.NORMAL]: '일반',
    [BRIEFING_STATUS.PENDING]: '예정',
    [BRIEFING_STATUS.COMPLETED]: '완료',
    [BRIEFING_STATUS.ONHOLD]: '보류'
  };
  return statusTexts[status] || '일반';
}

function applyBriefingFilters() {
  console.log('applyBriefingFilters 호출됨');
  console.log('현재 브리핑 필터 상태:', BRIEFING_FILTERS);
  
  // 브리핑 필터가 체크된 상태들 확인
  const checkedStatuses = Object.keys(BRIEFING_FILTERS).filter(status => BRIEFING_FILTERS[status]);
  console.log('체크된 브리핑 상태들:', checkedStatuses);
  
  let listingsToShow;
  
  if (checkedStatuses.length > 0) {
    // 체크된 브리핑 상태의 매물들만 표시
    listingsToShow = FILTERED_LISTINGS.filter(item => {
      const status = getBriefingStatus(item.id);
      const shouldShow = checkedStatuses.includes(status);
      console.log(`매물 ${item.id}: 브리핑 상태=${status}, 표시=${shouldShow}`);
      return shouldShow;
    });
  } else {
    // 아무것도 체크되지 않았으면 모든 매물 표시
    listingsToShow = [...FILTERED_LISTINGS];
  }
  
  console.log(`필터링 결과: ${FILTERED_LISTINGS.length}개 → ${listingsToShow.length}개`);
  
  placeMarkers(listingsToShow);
  
  // 브리핑리스트 모드일 때는 브리핑리스트를 렌더링, 아니면 일반 매물리스트
  if (UI_STATE.isBriefingListMode) {
    renderBriefingList();
  } else {
    renderListingList(listingsToShow);
  }
  
  updateCountsDisplay(FILTERED_LISTINGS.length, listingsToShow.length);
}

function initializeBriefingFilters() {
  const filterIds = ['filterNormal', 'filterPending', 'filterCompleted', 'filterOnHold'];
  const filterKeys = ['normal', 'pending', 'completed', 'onhold'];
  
  filterIds.forEach((id, index) => {
    const checkbox = document.getElementById(id);
    if (checkbox) {
      checkbox.checked = BRIEFING_FILTERS[filterKeys[index]];
      checkbox.addEventListener('change', (e) => {
        BRIEFING_FILTERS[filterKeys[index]] = e.target.checked;
        applyBriefingFilters();
      });
    }
  });
} 

/**************************************
 * ===== 로그인 화면 토글 =====
 **************************************/
function showLoginScreen(msg = "") {
  console.log("🔍 showLoginScreen 호출됨:", msg);
  
  const login   = document.getElementById("loginScreen");
  const appRoot = document.getElementById("appRoot");
  
  if (login) {
    login.classList.remove("hidden");
    login.style.display = "block";
    console.log("✅ 로그인 화면 표시");
  }
  
  if (appRoot) {
    appRoot.classList.add("hidden");
    appRoot.style.display = "none";
    console.log("✅ 앱 화면 숨김");
  }

  const m = document.getElementById("loginErrorMsg");
  if (m) m.textContent = msg || "";
}

function hideLoginScreen() {
  console.log("🔍 hideLoginScreen 호출됨");
  
  const login   = document.getElementById("loginScreen");
  const appRoot = document.getElementById("appRoot");
  
  if (login) {
    login.classList.add("hidden");
    login.style.display = "none";
    console.log("✅ 로그인 화면 숨김");
  }
  
  if (appRoot) {
    appRoot.classList.remove("hidden");
    appRoot.style.display = "block";
    console.log("✅ 앱 화면 표시");
  }

  toggleLoginLogoutUI(!!currentUser);
  fixMapLayoutAfterShow();
}

/**************************************
 * ===== 사용자(세션/수동) 처리 =====
 **************************************/
function setCurrentUser(email) {
  currentUser = email;
  localStorage.setItem("X-USER", email);
  const stat = document.getElementById("userStatus");
  if (stat) stat.textContent = email ? `사용자: ${email}` : "사용자 없음";
  toggleLoginLogoutUI(!!email);
}

function loadUserFromStorage() {
  const u = localStorage.getItem("X-USER");
  if (u) setCurrentUser(u);
}

function toggleLoginLogoutUI(isLoggedIn) {
  const loginBtn = document.getElementById("naverLoginBtn");
  const logoutBtn = document.getElementById("logoutBtn");
  const manualWrap = document.getElementById("manualUserWrap");

  if (loginBtn)  loginBtn.classList.toggle("hidden", isLoggedIn);
  if (logoutBtn) logoutBtn.classList.toggle("hidden", !isLoggedIn);
  if (manualWrap) manualWrap.classList.toggle("hidden", isLoggedIn);
}

function applyUser() {
  console.log("🔍 applyUser 함수 호출됨");
  
  const loginInp  = document.getElementById("loginEmail");
  const manualInp = document.getElementById("userEmail");

  let email = "";
  if (loginInp && loginInp.value.trim()) {
    email = loginInp.value.trim();
    console.log("🔍 로그인 이메일 입력:", email);
  } else if (manualInp && manualInp.value.trim()) {
    email = manualInp.value.trim();
    console.log("🔍 수동 이메일 입력:", email);
  }

  if (!email) {
    const m = document.getElementById("loginErrorMsg");
    if (m) m.textContent = "이메일을 입력하세요.";
    console.log("❌ 이메일이 입력되지 않음");
    return;
  }

  const EMAIL_RE = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/;
  if (!EMAIL_RE.test(email)) {
    const m = document.getElementById("loginErrorMsg");
    if (m) m.textContent = "올바른 이메일 형식이 아닙니다.";
    console.log("❌ 이메일 형식 오류:", email);
    return;
  }

  console.log("✅ 이메일 검증 통과:", email);
  
  // 사용자 설정
  setCurrentUser(email);
  
  // 로그인 화면 강제 숨김
  const loginScreen = document.getElementById("loginScreen");
  const appRoot = document.getElementById("appRoot");
  
  if (loginScreen) {
    loginScreen.classList.add("hidden");
    loginScreen.style.display = "none";
    console.log("✅ 로그인 화면 숨김");
  }
  
  if (appRoot) {
    appRoot.classList.remove("hidden");
    appRoot.style.display = "block";
    console.log("✅ 앱 화면 표시");
  }

  // 매물 데이터 로드
  runAfterMapReady(() => {
    // 재로그인 시에는 항상 데이터를 다시 로드
    FETCH_CALLED_ONCE = true;
    fetchListings();
    console.log("✅ 매물 데이터 로드 시작");
  });
  
  console.log("✅ 로그인 완료:", email);
}

function handleLogoutClick(e) {
  e.preventDefault();
  console.log("🔍 로그아웃 시작");

  try {
    localStorage.removeItem("X-USER");
    currentUser = null;
    console.log("✅ localStorage에서 사용자 정보 제거");
  } catch (err) {
    console.error("localStorage 제거 실패", err);
  }

  // 전역 상태 초기화
  FETCH_CALLED_ONCE = false;
  ORIGINAL_LIST = [];
  LISTINGS = [];
  
  // 지도 마커들 제거
  if (MAP && MARKERS) {
    MARKERS.forEach(marker => {
      if (marker && marker.setMap) {
        marker.setMap(null);
      }
    });
    MARKERS = [];
    console.log("✅ 지도 마커들 제거");
  }
  
  // 클러스터 그룹 초기화
  if (CLUSTER_GROUP && typeof CLUSTER_GROUP.clear === 'function') {
    CLUSTER_GROUP.clear();
    console.log("✅ 클러스터 그룹 초기화");
  }
  
  // 매물 리스트 초기화
  const ul = document.getElementById("listingList");
  if (ul) {
    ul.innerHTML = "";
    console.log("✅ 매물 리스트 초기화");
  }
  
  // 카운트 초기화
  updateCountsDisplay(0, 0);
  
  // 모든 패널 숨기기
  const panels = ["fullBriefingListPanel", "fullListPanel", "secondaryPanel"];
  panels.forEach(panelId => {
    const panel = document.getElementById(panelId);
    if (panel) {
      panel.classList.add("hidden");
      panel.style.display = "none";
    }
  });
  
  // UI 상태 초기화
  UI_STATE.showFullBriefingList = false;
  UI_STATE.showFullList = false;
  UI_STATE.isBriefingListMode = false;

  showLoginScreen("");

  fetch("/auth/logout", { method: "GET", credentials: "include" })
    .finally(() => {
      console.log("✅ 로그아웃 완료");
    });
}

function applyCustomerInputs() {
  const nameInp = document.getElementById("customerName");
  const phoneInp = document.getElementById("customerPhone");
  CURRENT_CUSTOMER.name  = nameInp ? nameInp.value.trim() : "";
  CURRENT_CUSTOMER.phone = phoneInp ? phoneInp.value.trim() : "";
  dbg("CURRENT_CUSTOMER", CURRENT_CUSTOMER);
}

function updateCountsDisplay(total, filtered) {
  const totalEl    = document.getElementById("countTotal");
  const filteredEl = document.getElementById("countFiltered");
  if (totalEl)    totalEl.textContent    = total;
  if (filteredEl) filteredEl.textContent = filtered;
} 

/**************************************
 * ===== 서버에서 매물 로드 =====
 **************************************/
async function fetchListings() {
  if (!currentUser) return;

  console.log("🔍 fetchListings 시작 - 사용자:", currentUser);

  // 기존 마커들 제거
  if (MARKERS && MARKERS.length > 0) {
    MARKERS.forEach(marker => {
      if (marker && marker.setMap) {
        marker.setMap(null);
      }
    });
    MARKERS = [];
    console.log("✅ 기존 마커들 제거");
  }

  // 클러스터 그룹 초기화
  if (CLUSTER_GROUP && typeof CLUSTER_GROUP.clear === 'function') {
    CLUSTER_GROUP.clear();
    console.log("✅ 클러스터 그룹 초기화");
  }

  const ul = document.getElementById("listingList");
  if (ul) ul.innerHTML = "<li>로딩...</li>";
  updateCountsDisplay(0, 0);

  const label = "fetchListings";
  timeStart(label);
  try {
    const qs = `limit=100000&status_raw=${encodeURIComponent(FIXED_STATUS)}`;
    dbg(`${label} start`, { user: currentUser });

    const res = await fetch(`/api/listings?${qs}`, {
      headers: { "X-User": currentUser }
    });
    if (!res.ok) throw new Error(`API 실패: ${res.status}`);

    const data = await res.json();
    ORIGINAL_LIST = data.items || [];
    LISTINGS = ORIGINAL_LIST.map(x => ({ ...x }));



    assignTempCoords();
    computeDistancesIfNeeded();

    applyAllFilters();
  } catch (e) {
    if (ul) ul.innerHTML = `<li style="color:red;">에러: ${escapeHtml(e.message)}</li>`;
    console.error("❌ fetchListings 오류:", e);
  } finally {
    timeEnd(label, { count: LISTINGS.length });
  }
}

/**************************************
 * ===== 필터 처리 =====
 **************************************/
function readTopFilterInputs() {
  const gv = id => (document.getElementById(id)?.value.trim() || "");
  TOP_FILTERS.region   = gv("tf_region");
  TOP_FILTERS.jibun    = gv("tf_jibun");
  TOP_FILTERS.building = gv("tf_building");
  TOP_FILTERS.floor    = gv("tf_floor");
  TOP_FILTERS.store    = gv("tf_store");
  TOP_FILTERS.area_sale = gv("tf_area_sale");
  TOP_FILTERS.area_real = gv("tf_area_real");
  TOP_FILTERS.deposit   = gv("tf_deposit");
  TOP_FILTERS.rent      = gv("tf_rent");
  TOP_FILTERS.premium   = gv("tf_premium");
  TOP_FILTERS.note      = gv("tf_note");
  TOP_FILTERS.manager   = gv("tf_manager");
  TOP_FILTERS.region2   = gv("tf_region2");
  TOP_FILTERS.phone     = gv("tf_phone");
  TOP_FILTERS.client    = gv("tf_client");
  TOP_FILTERS.note3     = gv("tf_note3");
}

function buildEffectiveFilters() {
  Object.keys(EFFECTIVE_FILTERS).forEach(k => {
    delete EFFECTIVE_FILTERS[k];
  });
  
  // 1. 고객 필터를 기본값으로 설정
  Object.assign(EFFECTIVE_FILTERS, CUSTOMER_FILTERS);
  
  // 2. 상단 필터가 활성화된 경우에만 고객 필터를 덮어씀
  Object.keys(TOP_FILTERS).forEach(k => {
    const v = TOP_FILTERS[k];
    if (v && v.trim() !== "") {
      EFFECTIVE_FILTERS[k] = v.trim();
    }
  });
}
function applyAllFilters() {
  dbg("applyAllFilters start");

  readTopFilterInputs();
  buildEffectiveFilters();
  
  // 필터 적용 시 정렬 상태 초기화
  resetSortCycles();
  
  // 디버깅: 현재 적용된 필터 확인
  // console.log('현재 적용된 필터:', EFFECTIVE_FILTERS);
  // console.log('총 매물 수:', LISTINGS.length);
  
  // 디버깅: 지역명 확인 (지역 + 지역2)
  const allRegions = [...new Set(LISTINGS.map(item => item.fields?.지역 || '').filter(r => r))];
  const allRegions2 = [...new Set(LISTINGS.map(item => item.fields?.지역2 || '').filter(r => r))];
  // console.log('전체 지역명 목록 (지역, 상위 20개):', allRegions.slice(0, 20));
  // console.log('전체 지역명 목록 (지역2, 상위 20개):', allRegions2.slice(0, 20));
  
  // 부평구 관련 디버그 로그 제거됨

  const FIELDS = {
    region:   "지역",
    jibun:    "지번",
    building: "건물명",
    floor:    "층수",
    store:    "가게명",
    area_sale:"분양",
    area_real:"실평수",
    deposit:  "보증금",
    rent:     "월세",
    premium:  "권리금",
    note:     "비고",
    manager:  "담당자",
    region2:  "지역2",
    phone:    "연락처",
    client:   "의뢰인",
    note3:    "비고3"
  };

  const TEXT_KEYS = ["region","jibun","building","store","note","manager","region2","phone","client","note3"];
  const NUM_CONFIG = {
    area_sale:"gte",
    area_real:"gte",
    deposit:  "lte",
    rent:     "lte",
    premium:  "lte"
  };

  const parsedText = {};
  TEXT_KEYS.forEach(k => {
    parsedText[k] = parseTextTokens(EFFECTIVE_FILTERS[k] || "");
  });

  const parsedNum = {};
  Object.keys(NUM_CONFIG).forEach(k => {
    parsedNum[k] = buildNumFilter(EFFECTIVE_FILTERS[k] || "", NUM_CONFIG[k]);
  });

  const floorFilter = buildFloorFilter(EFFECTIVE_FILTERS.floor || "");

  const arr = LISTINGS.filter(item => {
    const fields = item.fields || {};

    for (const tk of TEXT_KEYS) {
      const v = fields[FIELDS[tk]] || "";
      if (!matchesTextTokens(v, parsedText[tk])) return false;
    }

    const fVal = parseFloorValue(fields[FIELDS.floor]);
    if (!checkNumFilter(fVal, floorFilter)) return false;

    const asVal = parseNumber(fields[FIELDS.area_sale]);
    if (!checkNumFilter(asVal, parsedNum.area_sale)) return false;

    const arVal = parseNumber(fields[FIELDS.area_real]);
    if (!checkNumFilter(arVal, parsedNum.area_real)) return false;

    const dVal = parseNumber(fields[FIELDS.deposit]);
    if (!checkNumFilter(dVal, parsedNum.deposit)) return false;

    const rVal = parseNumber(fields[FIELDS.rent]);
    if (!checkNumFilter(rVal, parsedNum.rent)) return false;

    const pVal = parseNumber(fields[FIELDS.premium]);
    if (!checkNumFilter(pVal, parsedNum.premium)) return false;

    return true;
  });

  sortListingsInPlace(arr);
  FILTERED_LISTINGS = arr;
  
  // 디버깅: 필터링 결과 확인
  // console.log('필터링된 매물 수:', arr.length);
  if (arr.length === 0) {
    console.log('매물이 없습니다. 필터 조건이 너무 엄격할 수 있습니다.');
  }
  
  // 디버깅: 각 필터 조건별 매물 수 확인
  if (EFFECTIVE_FILTERS.region2) {
    const region2Matches = LISTINGS.filter(item => {
      const region2 = item.fields?.지역2 || '';
      return region2.includes(EFFECTIVE_FILTERS.region2);
    });
    console.log(`지역2 필터 (${EFFECTIVE_FILTERS.region2}) 매물 수:`, region2Matches.length);
  }
  
  if (EFFECTIVE_FILTERS.floor) {
    const floorMatches = LISTINGS.filter(item => {
      const floor = item.fields?.층수 || '';
      return floor.includes(EFFECTIVE_FILTERS.floor);
    });
    console.log(`층수 필터 (${EFFECTIVE_FILTERS.floor}) 매물 수:`, floorMatches.length);
  }
  
  if (EFFECTIVE_FILTERS.area_real) {
    const areaMatches = LISTINGS.filter(item => {
      const area = parseNumber(item.fields?.실평수) || 0;
      return area >= parseNumber(EFFECTIVE_FILTERS.area_real);
    });
    console.log(`면적 필터 (${EFFECTIVE_FILTERS.area_real}평 이상) 매물 수:`, areaMatches.length);
  }
  
  if (EFFECTIVE_FILTERS.deposit) {
    const depositFilter = buildNumFilter(EFFECTIVE_FILTERS.deposit, "lte");
    const depositMatches = LISTINGS.filter(item => {
      const deposit = parseNumber(item.fields?.보증금) || 0;
      return checkNumFilter(deposit, depositFilter);
    });
    console.log(`보증금 필터 (${EFFECTIVE_FILTERS.deposit}) 매물 수:`, depositMatches.length);
  }
  
  dbg("applyAllFilters end");
  
  // 브리핑 필터 적용
  applyBriefingFilters();

  setLayoutHeight();

  // 지도 이벤트 트리거는 초기 로드 시에만 실행
  if (MAP_READY && FETCH_CALLED_ONCE) {
    console.log("🔍 지도 idle 이벤트 트리거");
    naver.maps.Event.trigger(MAP, 'idle');
  }
}

// 정렬 순환 상태 초기화 함수
function resetSortCycles() {
  Object.keys(CURRENT_SORT_CYCLES).forEach(key => {
    CURRENT_SORT_CYCLES[key] = 0;
  });
  CURRENT_SORT_MODE = "latest";
}



function sortListingsInPlace(arr) {
  switch (CURRENT_SORT_MODE) {
    case "latest":
      arr.sort((a, b) => {
        const da = new Date(a.fields["접수날짜"] || 0).getTime();
        const db = new Date(b.fields["접수날짜"] || 0).getTime();
        return db - da;
      });
      break;
    case "oldest":
      arr.sort((a, b) => {
        const da = new Date(a.fields["접수날짜"] || 0).getTime();
        const db = new Date(b.fields["접수날짜"] || 0).getTime();
        return da - db;
      });
      break;
    case "area_high":
      arr.sort((a, b) => {
        const na = parseNumber(a.fields["실평수"]);
        const nb = parseNumber(b.fields["실평수"]);
        return (nb || 0) - (na || 0);
      });
      break;
    case "area_low":
      arr.sort((a, b) => {
        const na = parseNumber(a.fields["실평수"]);
        const nb = parseNumber(b.fields["실평수"]);
        return (na || 0) - (nb || 0);
      });
      break;
    case "deposit_low":
      arr.sort((a, b) => {
        const da = parseNumber(a.fields["보증금"]);
        const db = parseNumber(b.fields["보증금"]);
        return (da || 0) - (db || 0);
      });
      break;
    case "deposit_high":
      arr.sort((a, b) => {
        const da = parseNumber(a.fields["보증금"]);
        const db = parseNumber(b.fields["보증금"]);
        return (db || 0) - (da || 0);
      });
      break;
    case "rent_low":
      arr.sort((a, b) => {
        const ra = parseNumber(a.fields["월세"]);
        const rb = parseNumber(b.fields["월세"]);
        return (ra || 0) - (rb || 0);
      });
      break;
    case "rent_high":
      arr.sort((a, b) => {
        const ra = parseNumber(a.fields["월세"]);
        const rb = parseNumber(b.fields["월세"]);
        return (rb || 0) - (ra || 0);
      });
      break;
    case "default":
      // 기본 정렬 (접수날짜 최신순)
      arr.sort((a, b) => {
        const da = new Date(a.fields["접수날짜"] || 0).getTime();
        const db = new Date(b.fields["접수날짜"] || 0).getTime();
        return db - da;
      });
      break;
    default:
      break;
  }
}

function renderListingList(arr) {
  const ul = document.getElementById("listingList");
  if (!ul) return;

  ul.innerHTML = "";
  arr.forEach(item => {
    const fields     = item.fields || {};
    const addr       = escapeHtml(item.address_full || "");
    const floorRaw   = fields["층수"] || fields["층"] || "";
    const floor      = floorRaw
      ? (/층|지하|^b\d+/i.test(floorRaw) ? floorRaw : `${floorRaw}층`)
      : "-";
    const areaReal   = escapeHtml(fields["실평수"] || "-");
    const dep        = escapeHtml(fields["보증금"] || "-");
    const rent       = escapeHtml(fields["월세"]   || "-");
    const premRaw    = (fields["권리금"] ?? "").toString().trim();
    const premDisplay= ["", "무권리", "0", "무"].includes(premRaw)
      ? "무권리"
      : `권: ${escapeHtml(premRaw)}`;

    const li = document.createElement("li");
    li.dataset.id = item.id;
    li.style.position = 'relative';
    li.innerHTML = `
      <div class="listing-item">
        <div class="meta-top">
          <span class="addr">${addr}</span>
          <span class="floor">${floor}</span>
          <span class="area-real">${areaReal}평</span>
        </div>
        <div class="meta-bottom">
          <span>보: ${dep}</span>
          <span>월: ${rent}</span>
          <span>${premDisplay}</span>
        </div>
      </div>
    `;
    
    // 브리핑 상태 표시 추가
    const briefingStatus = getBriefingStatus(item.id);
    updateListingItemBriefingStatus(li, briefingStatus);

    li.addEventListener("click", () => {
      clearSelection();
      setActiveMarker(item.id);
      renderDetailPanel(item);
      
      // 선택 상태 업데이트
      ul.querySelectorAll("li .listing-item.selected")
        .forEach(el => el.classList.remove("selected"));
      const inner = li.querySelector(".listing-item");
      if (inner) {
        inner.classList.add("selected");
      }
      
      // 클릭 시 애니메이션 효과 추가
      const marker = MARKERS.find(m => m._listingId === item.id);
      if (marker && marker.getElement) {
        const dotEl = marker.getElement().querySelector(".marker-dot");
        if (dotEl) {
          dotEl.classList.add("blink");
          setTimeout(() => dotEl.classList.remove("blink"), 800);
        }
      }
      
      // 클러스터 버블 애니메이션도 시도
      if (CLUSTERER && CLUSTERER._clusters) {
        const clusterObj = CLUSTERER._clusters.find(c =>
          c.getClusterMember().some(m => m._listingId === item.id)
        );
        if (clusterObj && clusterObj._clusterMarker) {
          const bubble = clusterObj._clusterMarker
            .getElement()
            .querySelector(".cluster-bubble");
          if (bubble) {
            bubble.classList.remove("cluster-animate");
            void bubble.offsetWidth;
            bubble.classList.add("cluster-animate");
          }
        }
      }
    });

    // 마우스오버 이벤트 추가
    li.addEventListener("mouseenter", () => {
      highlightMarkerTemp(item.id, true);
      
      // 마커 도트 blink 효과
      const marker = MARKERS.find(m => m._listingId === item.id);
      if (marker && marker.getElement) {
        const dotEl = marker.getElement().querySelector(".marker-dot");
        if (dotEl) {
          dotEl.classList.add("blink");
          setTimeout(() => dotEl.classList.remove("blink"), 800);
        }
      }
      
      // 클러스터 버블 blink 효과 추가
      if (CLUSTERER && CLUSTERER._clusters) {
        const clusterObj = CLUSTERER._clusters.find(c =>
          c.getClusterMember().some(m => m._listingId === item.id)
        );
        if (clusterObj && clusterObj._clusterMarker) {
          const bubble = clusterObj._clusterMarker
            .getElement()
            .querySelector(".cluster-bubble");
          if (bubble) {
            // console.log("🔥 매물 리스트 마우스오버 - 클러스터 버블 애니메이션:", bubble);
            bubble.style.animation = "clusterBlinkHover 0.6s ease-in-out";
            setTimeout(() => {
              bubble.style.animation = "";
            }, 600);
          }
        }
      }
    });

    li.addEventListener("mouseleave", () => {
      highlightMarkerTemp(item.id, false);
    });

    ul.appendChild(li);
  });
}

function scrollToListing(id) {
  const ul = document.getElementById("listingList");
  if (!ul) return;
  const li = ul.querySelector(`li[data-id="${id}"]`);
  if (!li) return;

  li.scrollIntoView({ behavior: "smooth", block: "center" });

  if (CURRENT_SELECTED_LI_ID) {
    const prev = ul.querySelector(`li[data-id="${CURRENT_SELECTED_LI_ID}"] .listing-item`);
    if (prev) prev.classList.remove("selected");
  }
  CURRENT_SELECTED_LI_ID = id;

  const inner = li.querySelector(".listing-item");
  if (inner) {
    inner.classList.add("selected");
  }
} 
/**************************************
 * ===== 지도 및 마커 관리 =====
 **************************************/
function placeMarkers(arr) {
  if (!MAP) return;
  if (!Array.isArray(arr)) return;

  if (MARKERS && MARKERS.length) {
    MARKERS.forEach(m => m.setMap && m.setMap(null));
    MARKERS = [];
  }
  if (CLUSTERER) {
    try { CLUSTERER.setMap(null); } catch (e) {}
    CLUSTERER = null;
  }

  const bounds = new naver.maps.LatLngBounds();

  arr.forEach(item => {
    const { lat, lng } = item.coords || {};
    if (lat == null || lng == null) return;
    const pos   = new naver.maps.LatLng(lat, lng);
    const color = STATUS_COLORS[item.status_raw] || "#007AFF";

    const marker = new naver.maps.Marker({
      position: pos,
      map: null,
      icon: { content: createMarkerIcon(color, item.id === SELECTED_MARKER_ID, getBriefingStatus(item.id)) }
    });
    marker._listingId = item.id;

    naver.maps.Event.addListener(marker, "click", () => {
      setActiveMarker(item.id);
      scrollToListing(item.id);
      renderDetailPanel(item);
    });

    MARKERS.push(marker);
    bounds.extend(pos);
  });

  // MarkerClustering이 로드될 때까지 대기
  if (typeof MarkerClustering !== "undefined" && MarkerClustering) {
    CLUSTERER = new MarkerClustering({
      minClusterSize: 2,
      maxZoom: MAP.getMaxZoom(),
      map: MAP,
      markers: MARKERS,
      disableClickZoom: true,
      gridSize: 80,

      stylingFunction: function(clusterMarker, count) {
        let cls = "cluster-small";
        if (count >= 50)      cls = "cluster-big";
        else if (count >= 10) cls = "cluster-mid";

        // 클러스터 객체 찾기 (안전하게 처리)
        let clusterObj = null;
        if (CLUSTERER && CLUSTERER._clusters) {
          clusterObj = CLUSTERER._clusters.find(
            c => c._clusterMarker === clusterMarker
          );
        }
        
        // 브리핑 상태 분석
        let bubbleStyle = "";
        let bubbleContent = count;
        
        if (clusterObj && clusterObj.getClusterMember) {
          const clusterMembers = clusterObj.getClusterMember();
          const briefingStats = {
            normal: 0,
            pending: 0,
            completed: 0,
            onhold: 0
          };
          
          clusterMembers.forEach(marker => {
            const status = getBriefingStatus(marker._listingId);
            briefingStats[status]++;
          });
          
          // 브리핑 상태가 있는 매물이 있으면 색상 변경
          const hasBriefingItems = briefingStats.pending > 0 || briefingStats.completed > 0 || briefingStats.onhold > 0;
          
          if (hasBriefingItems) {
            // 주요 브리핑 상태 결정 (우선순위: 완료 > 예정 > 보류)
            let primaryStatus = BRIEFING_STATUS.NORMAL;
            if (briefingStats.completed > 0) {
              primaryStatus = BRIEFING_STATUS.COMPLETED;
            } else if (briefingStats.pending > 0) {
              primaryStatus = BRIEFING_STATUS.PENDING;
            } else if (briefingStats.onhold > 0) {
              primaryStatus = BRIEFING_STATUS.ONHOLD;
            }
            
            // 브리핑 상태별 색상
            const statusColors = {
              [BRIEFING_STATUS.NORMAL]: '#007AFF',
              [BRIEFING_STATUS.PENDING]: '#FF3B30',
              [BRIEFING_STATUS.COMPLETED]: '#34C759',
              [BRIEFING_STATUS.ONHOLD]: '#AF52DE'
            };
            
            bubbleStyle = `background-color: ${statusColors[primaryStatus]} !important; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);`;
          }
        }

        const bubbleHtml = `<div class="cluster-bubble ${cls}" style="${bubbleStyle}">${bubbleContent}</div>`;
        const wrapper = clusterMarker.getElement();
        wrapper.innerHTML = bubbleHtml;

        try { clusterMarker.setZIndex(8000 + count); } catch (e) {}

        // 클러스터 클릭 이벤트를 더 직접적으로 처리
        wrapper.style.cursor = "pointer";
        wrapper.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log("🔥 클러스터 클릭됨 (wrapper):", clusterMarker);

          // 버블 애니메이션 효과 - 더 강력한 방법
          const bubble = wrapper.querySelector(".cluster-bubble");
          if (bubble) {
            console.log("버블 요소 찾음:", bubble);
            
            // 기존 애니메이션 클래스 제거
            bubble.classList.remove("cluster-animate");
            
            // 강제 리플로우
            bubble.offsetHeight;
            
            // 애니메이션 클래스 다시 추가
            bubble.classList.add("cluster-animate");
            
            // 애니메이션 완료 후 클래스 제거
            setTimeout(() => {
              bubble.classList.remove("cluster-animate");
            }, 350);
            
            console.log("애니메이션 클래스 추가됨:", bubble.classList.contains("cluster-animate"));
          } else {
            console.log("버블 요소를 찾을 수 없음");
          }

          // 클러스터 객체 찾기
          const clusterObj = CLUSTERER._clusters.find(
            c => c._clusterMarker === clusterMarker
          );
          if (clusterObj) {
            console.log("클러스터 객체 찾음:", clusterObj);
            renderClusterGroupList(clusterObj);
          } else {
            console.log("클러스터 객체를 찾을 수 없음");
          }
        });

        // 마우스오버 효과도 추가
        wrapper.addEventListener("mouseenter", () => {
          wrapper.style.transform = "scale(1.1)";
          wrapper.style.transition = "transform 0.2s ease";
          
          // 클러스터 버블 blink 효과
          const bubble = wrapper.querySelector(".cluster-bubble");
          if (bubble) {
            bubble.style.animation = "clusterBlinkHover 0.6s ease-in-out";
            setTimeout(() => {
              bubble.style.animation = "";
            }, 600);
          }
        });

        wrapper.addEventListener("mouseleave", () => {
          wrapper.style.transform = "scale(1)";
        });

        // 클러스터 버블에도 직접 이벤트 추가
        const bubble = wrapper.querySelector(".cluster-bubble");
        if (bubble) {
          // 클릭 이벤트
          bubble.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log("🔥 클러스터 버블 직접 클릭됨:", bubble);
            
            // CSS 클래스 애니메이션
            bubble.classList.remove("cluster-animate");
            bubble.offsetHeight;
            bubble.classList.add("cluster-animate");
            
            const clusterObj = CLUSTERER._clusters.find(
              c => c._clusterMarker === clusterMarker
            );
            if (clusterObj) {
              renderClusterGroupList(clusterObj);
            }
          });
          
          // 마우스오버 이벤트
          bubble.addEventListener("mouseenter", () => {
            console.log("🔥 클러스터 버블 마우스오버:", bubble);
            bubble.style.animation = "clusterBlinkHover 0.6s ease-in-out";
            setTimeout(() => {
              bubble.style.animation = "";
            }, 600);
          });
        }
      }
    });
  } else {
    // MarkerClustering이 로드되지 않은 경우 개별 마커로 표시
    console.log('⚠️ MarkerClustering이 로드되지 않아 개별 마커로 표시합니다.');
    MARKERS.forEach(m => m.setMap(MAP));
  }
}

function setActiveMarker(id){
  SELECTED_MARKER_ID = id;
  MARKERS.forEach(m => {
    const color = STATUS_COLORS[LISTINGS.find(x => x.id === m._listingId)?.status_raw] || "#007AFF";
    const isActive = (m._listingId === id);
    const briefingStatus = getBriefingStatus(m._listingId);
    m.setIcon({ content: createMarkerIcon(color, isActive, briefingStatus) });
    m.setZIndex(isActive ? 9999 : 1);
  });
}

function highlightMarkerTemp(id, on) {
  MARKERS.forEach(m => {
    if (m._listingId === id) {
      const color = STATUS_COLORS[LISTINGS.find(x => x.id === id)?.status_raw] || "#007AFF";
      const isActive = (m._listingId === SELECTED_MARKER_ID);
      const briefingStatus = getBriefingStatus(m._listingId);
      
      if (on) {
        // 마우스오버 시 더 큰 크기와 밝은 색상
        const cls = "marker-dot active";
        m.setIcon({ 
          content: `<div class="${cls}" style="background:${color}; transform: scale(1.5); box-shadow: 0 0 10px ${color};"></div>` 
        });
        m.setZIndex(5000);
      } else {
        // 마우스아웃 시 원래 상태로 복원 (브리핑 상태 포함)
        m.setIcon({ content: createMarkerIcon(color, isActive, briefingStatus) });
        m.setZIndex(isActive ? 9999 : 1);
      }
    }
  });
}

function focusMarker(id, panTo = true) {
  const marker = MARKERS.find(m => m._listingId === id);
  if (!marker) return;
  setActiveMarker(id);
  if (panTo) {
    try { MAP.panTo(marker.getPosition()); } catch(e){}
  }
}

function createMarkerIcon(color = "#007AFF", active = false, briefingStatus = BRIEFING_STATUS.NORMAL){
  // 브리핑 상태에 따른 색상 결정
  let markerColor = color;
  if (briefingStatus !== BRIEFING_STATUS.NORMAL) {
    const statusColors = {
      [BRIEFING_STATUS.PENDING]: '#FF3B30',    // 빨간색 (예정)
      [BRIEFING_STATUS.COMPLETED]: '#34C759',  // 초록색 (완료)
      [BRIEFING_STATUS.ONHOLD]: '#AF52DE'      // 보라색 (보류)
    };
    markerColor = statusColors[briefingStatus] || color;
  }
  
  let cls = active ? "marker-dot active" : "marker-dot";
  return `<div class="${cls}" style="background:${markerColor};"></div>`;
}

function fixMapLayoutAfterShow() {
  const doFix = () => {
    setLayoutHeight();
    if (MAP) {
      naver.maps.Event.trigger(MAP, 'resize');
    }
  };
  requestAnimationFrame(doFix);
  setTimeout(doFix, 350);
}

function calcHaversineMeters(lat1, lng1, lat2, lng2) {
  const R = 6371000;
  const toRad = deg => deg * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  const a = Math.sin(dLat/2)**2 +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLng/2)**2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

function getDistanceMeters(centerLatLng, targetLatLng) {
  if (window.naver && naver.maps &&
      naver.maps.GeometryUtil && naver.maps.GeometryUtil.getDistance) {
    return naver.maps.GeometryUtil.getDistance(centerLatLng, targetLatLng);
  }
  return calcHaversineMeters(
    centerLatLng.lat(), centerLatLng.lng(),
    targetLatLng.lat(), targetLatLng.lng()
  );
}

function computeDistancesIfNeeded() {
  if (!MAP) return;
  const c = MAP.getCenter();
  if (!c) return;

  const cx = c.x, cy = c.y;
  if (LAST_DISTANCE_CENTER && LAST_DISTANCE_CENTER.x === cx && LAST_DISTANCE_CENTER.y === cy) {
    return;
  }
  LAST_DISTANCE_CENTER = { x: cx, y: cy };

  LISTINGS.forEach(item => {
    const { lat, lng } = item.coords || {};
    if (lat == null || lng == null) {
      item._distance = null;
      return;
    }
    const d = getDistanceMeters(c, new naver.maps.LatLng(lat, lng));
    item._distance = d;
  });
}

function assignTempCoords() {
  LISTINGS.forEach((item, i) => {
    if (!item.coords || item.coords.lat == null || item.coords.lng == null) {
      const baseLat = 37.5665;
      const baseLng = 126.9780;
      item.coords = { lat: baseLat + (i * 0.0001), lng: baseLng + (i * 0.0001) };
    }
  });
}

function renderClusterGroupList(cluster) {
  const markers = cluster.getClusterMember();
  const ids     = markers.map(m => m._listingId);
  const arr     = LISTINGS.filter(x => ids.includes(x.id));

  const wrap = document.getElementById("clusterList");
  const ul   = document.getElementById("clusterItemList");
  const listingList = document.getElementById("listingList");
  if (!wrap || !ul) return;

  // 매물리스트 숨기고 클러스터 리스트 표시
  if (listingList) listingList.style.visibility = "hidden";
  ul.innerHTML = "";

  arr.forEach(item => {
    const fields      = item.fields || {};
    const addr        = escapeHtml(item.address_full || "");
    const floor       = escapeHtml(fields["층수"]   || "-");
    const area_real   = escapeHtml(fields["실평수"] || "-");
    const dep         = escapeHtml(fields["보증금"] || "-");
    const rent        = escapeHtml(fields["월세"]   || "-");
    const rawPrem     = (fields["권리금"] ?? "").toString().trim();
    const premDisplay = ["", "무권리", "0", "무"].includes(rawPrem)
      ? "무권리"
      : `권: ${escapeHtml(rawPrem)}`;

    const li = document.createElement("li");
    li.classList.add("listing-item");
    li.setAttribute("data-id", item.id);
    li.style.position = 'relative';
    li.innerHTML = `
      <div class="title">${addr}</div>
      <div class="meta">
        ${floor}층 / 실평수 ${area_real}평 /
        보증금 ${dep} / 월세 ${rent} / ${premDisplay}
      </div>
    `;
    
    // 브리핑 상태 표시 추가
    const briefingStatus = getBriefingStatus(item.id);
    updateListingItemBriefingStatus(li, briefingStatus);

    li.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      setActiveMarker(item.id);

      let clusterObj = null;
      if (CLUSTERER && Array.isArray(CLUSTERER._clusters)) {
        clusterObj = CLUSTERER._clusters.find(c =>
          c.getClusterMember().some(m => m._listingId === item.id)
        );
      }
      if (clusterObj && clusterObj._clusterMarker) {
        const bubble = clusterObj._clusterMarker
          .getElement()
          .querySelector(".cluster-bubble");
        if (bubble) {
          bubble.classList.remove("cluster-animate");
          void bubble.offsetWidth;
          bubble.classList.add("cluster-animate");
        }
      }

      const mk = MARKERS.find(m => m._listingId === item.id);
      if (mk?.getElement) {
        const dotEl = mk.getElement().querySelector(".marker-dot");
        if (dotEl) {
          dotEl.classList.add("blink");
          setTimeout(() => dotEl.classList.remove("blink"), 800);
        }
      }

      ul.querySelectorAll("li.selected")
        .forEach(el => el.classList.remove("selected"));
      li.classList.add("selected");

      const mainUl = document.getElementById("listingList");
      const mainLi = mainUl?.querySelector(`li[data-id="${item.id}"]`);
      if (mainLi) {
        const inner = mainLi.querySelector(".listing-item");
        if (inner) {
          inner.classList.add("selected");
          mainLi.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }
      renderDetailPanel(item);
    });

    // 클러스터 목록 마우스오버 이벤트 추가
    li.addEventListener("mouseenter", () => {
      highlightMarkerTemp(item.id, true);
      
      // 마커 도트 blink 효과
      const marker = MARKERS.find(m => m._listingId === item.id);
      if (marker && marker.getElement) {
        const dotEl = marker.getElement().querySelector(".marker-dot");
        if (dotEl) {
          dotEl.classList.add("blink");
          setTimeout(() => dotEl.classList.remove("blink"), 800);
        }
      }
      
      // 클러스터 버블 blink 효과 추가
      if (CLUSTERER && CLUSTERER._clusters) {
        const clusterObj = CLUSTERER._clusters.find(c =>
          c.getClusterMember().some(m => m._listingId === item.id)
        );
        if (clusterObj && clusterObj._clusterMarker) {
          const bubble = clusterObj._clusterMarker
            .getElement()
            .querySelector(".cluster-bubble");
          if (bubble) {
            bubble.style.animation = "clusterBlinkHover 0.6s ease-in-out";
            setTimeout(() => {
              bubble.style.animation = "";
            }, 600);
          }
        }
      }
    });

    li.addEventListener("mouseleave", () => {
      highlightMarkerTemp(item.id, false);
    });

    ul.appendChild(li);
  });

  wrap.classList.remove("hidden");
  
  // 클러스터 리스트 닫기 버튼 이벤트 리스너 추가
  const closeBtn = document.getElementById("clusterListCloseBtn");
  if (closeBtn) {
    closeBtn.onclick = () => {
      hideClusterList();
    };
  }
}

function hideClusterList() {
  const wrap = document.getElementById("clusterList");
  const listingList = document.getElementById("listingList");
  if (wrap) wrap.classList.add("hidden");
  // 클러스터 리스트가 숨겨질 때 매물리스트 다시 표시
  if (listingList) listingList.style.visibility = "visible";
}
function bindClusterClickDelegation() {
  if (_clusterClickDelegationBound) return;
  const mapWrap = document.getElementById("mapWrap");
  if (!mapWrap) return;

  mapWrap.addEventListener("click", (e) => {
    // 클러스터 버블을 직접 클릭한 경우
    if (e.target.classList.contains("cluster-bubble")) {
      const wrapper = e.target.closest("div[title]");
      if (!wrapper || !CLUSTERER) return;

      const cluster = CLUSTERER._clusters.find(
        c => c._clusterMarker.getElement() === wrapper
      );
      if (!cluster) return;

      console.log("🔥 클러스터 버블 클릭됨 (delegation):", cluster);

      // 버블 애니메이션 효과
      const bubble = wrapper.querySelector(".cluster-bubble");
      if (bubble) {
        bubble.classList.remove("cluster-animate");
        void bubble.offsetWidth; // 리플로우 강제
        bubble.classList.add("cluster-animate");
      }

      renderClusterGroupList(cluster);
      return;
    }

    // 클러스터 wrapper를 클릭한 경우
    const wrapper = e.target.closest("div[title]");
    if (!wrapper || !CLUSTERER) return;

    const cluster = CLUSTERER._clusters.find(
      c => c._clusterMarker.getElement() === wrapper
    );
    if (!cluster) return;

    console.log("🔥 클러스터 wrapper 클릭됨 (delegation):", cluster);

    const bubble = wrapper.querySelector(".cluster-bubble");
    if (bubble) {
      bubble.classList.remove("cluster-animate");
      void bubble.offsetWidth; // 리플로우 강제
      bubble.classList.add("cluster-animate");
    }

    renderClusterGroupList(cluster);
  });

  _clusterClickDelegationBound = true;
} 

/**************************************
 * ===== 패널 토글/전체보기 =====
 **************************************/
function openCustomerPanel(customerId, view = "detail") {
  UI_STATE.selectedCustomerId = customerId;
  UI_STATE.currentCustomerView = view;
  UI_STATE.showCustomerPanel  = true;

  const panel = document.getElementById("customerPanel");
  const detail = document.getElementById("viewCustomerDetail");
  const form   = document.getElementById("viewCustomerForm");
  const title  = document.getElementById("customerPanelTitle");

  if (panel) panel.classList.remove("hidden");

  if (view === "form") {
    if (detail) detail.classList.add("hidden");
    if (form)   form.classList.remove("hidden");
    if (title)  title.textContent = "신규 등록";
  } else {
    if (detail) detail.classList.remove("hidden");
    if (form)   form.classList.add("hidden");
    if (title)  title.textContent = "고객 상세";
  }

  setLayoutHeight();
  if (MAP) naver.maps.Event.trigger(MAP, 'resize');
}

function closeCustomerPanel() {
  UI_STATE.showCustomerPanel = false;
  const panel = document.getElementById("customerPanel");
  if (panel) panel.classList.add("hidden");
  setLayoutHeight();
  if (MAP) naver.maps.Event.trigger(MAP, 'resize');
}

function switchToListingMode(mode) {
  UI_STATE.isBriefingListMode = (mode === 'briefing');
  
  const propertyBtn = document.getElementById("propertyListBtn");
  const briefingBtn = document.getElementById("briefingListBtn");
  
  if (UI_STATE.isBriefingListMode) {
    // 브리핑 리스트 모드로 전환
    if (propertyBtn) {
      propertyBtn.classList.remove("active");
      propertyBtn.removeAttribute("data-mode");
    }
    if (briefingBtn) {
      briefingBtn.classList.add("active");
      briefingBtn.setAttribute("data-mode", "briefing");
    }
    renderBriefingList();
  } else {
    // 일반 매물 리스트 모드로 전환
    if (propertyBtn) {
      propertyBtn.classList.add("active");
      propertyBtn.setAttribute("data-mode", "property");
    }
    if (briefingBtn) {
      briefingBtn.classList.remove("active");
      briefingBtn.removeAttribute("data-mode");
    }
    applyAllFilters();
  }
}

// 기존 함수명 유지 (하위 호환성)
function toggleBriefingList() {
  switchToListingMode(UI_STATE.isBriefingListMode ? 'property' : 'briefing');
}

function toggleFullBriefingList(show) {
  UI_STATE.showFullBriefingList = (show !== undefined) ? show : !UI_STATE.showFullBriefingList;
  const panel = document.getElementById("fullBriefingListPanel");
  if (!panel) {
    console.error("❌ fullBriefingListPanel을 찾을 수 없습니다.");
    return;
  }
  
  console.log("🔍 toggleFullBriefingList 호출됨:", UI_STATE.showFullBriefingList);
  console.log("🔍 패널 요소:", panel);
  console.log("🔍 현재 클래스:", panel.className);
  
  if (UI_STATE.showFullBriefingList) {
    panel.classList.remove("hidden");
    console.log("🔍 hidden 클래스 제거됨, 새로운 클래스:", panel.className);
    console.log("🔍 패널 스타일:", panel.style.display);
    renderFullBriefingList();
    console.log("🔍 전체브리핑리스트 열기 완료");
  } else {
    panel.classList.add("hidden");
    console.log("🔍 hidden 클래스 추가됨, 새로운 클래스:", panel.className);
    console.log("🔍 전체브리핑리스트 닫기 완료");
  }
}

function toggleFullList(show) {
  UI_STATE.showFullList = (show !== undefined) ? show : !UI_STATE.showFullList;
  const panel = document.getElementById("fullListPanel");
  if (!panel) {
    console.error("❌ fullListPanel을 찾을 수 없습니다.");
    return;
  }
  
  console.log("🔍 toggleFullList 호출됨:", UI_STATE.showFullList);
  console.log("🔍 패널 요소:", panel);
  console.log("🔍 현재 클래스:", panel.className);
  
  if (UI_STATE.showFullList) {
    panel.classList.remove("hidden");
    console.log("🔍 hidden 클래스 제거됨, 새로운 클래스:", panel.className);
    console.log("🔍 패널 스타일:", panel.style.display);
    renderFullList();
    console.log("🔍 전체리스트 열기 완료");
  } else {
    panel.classList.add("hidden");
    console.log("🔍 hidden 클래스 추가됨, 새로운 클래스:", panel.className);
    console.log("🔍 전체리스트 닫기 완료");
  }
}

function renderBriefingList() {
  // 브리핑 현황이 체크된 매물만 필터링
  const briefingListings = LISTINGS.filter(item => {
    const status = getBriefingStatus(item.id);
    return status !== BRIEFING_STATUS.NORMAL; // 일반이 아닌 모든 상태 (예정, 완료, 보류)
  });
  
  // 현재 상단 필터 적용
  const effectiveFilters = buildEffectiveFilters();
  let filteredListings = briefingListings;
  
  if (effectiveFilters && Object.keys(effectiveFilters).length > 0) {
    filteredListings = briefingListings.filter(item => {
      const fields = item.fields || {};
      
      // 지역 필터
      if (effectiveFilters.region && effectiveFilters.region.length > 0) {
        const itemRegion = fields['지역'] || '';
        if (!effectiveFilters.region.some(r => itemRegion.includes(r))) {
          return false;
        }
      }
      
      // 지번 필터
      if (effectiveFilters.jibun && effectiveFilters.jibun.length > 0) {
        const itemJibun = fields['지번'] || '';
        if (!effectiveFilters.jibun.some(j => itemJibun.includes(j))) {
          return false;
        }
      }
      
      // 건물명 필터
      if (effectiveFilters.building && effectiveFilters.building.length > 0) {
        const itemBuilding = fields['건물명'] || '';
        if (!effectiveFilters.building.some(b => itemBuilding.includes(b))) {
          return false;
        }
      }
      
      // 층수 필터
      if (effectiveFilters.floor && effectiveFilters.floor.length > 0) {
        const itemFloor = fields['층수'] || '';
        if (!effectiveFilters.floor.some(f => itemFloor.includes(f))) {
          return false;
        }
      }
      
      // 실평수 필터
      if (effectiveFilters.area && effectiveFilters.area.length > 0) {
        const itemArea = parseFloat(fields['실평수']) || 0;
        const areaFilter = effectiveFilters.area[0];
        if (areaFilter.min !== null && itemArea < areaFilter.min) return false;
        if (areaFilter.max !== null && itemArea > areaFilter.max) return false;
      }
      
      // 보증금 필터
      if (effectiveFilters.deposit && effectiveFilters.deposit.length > 0) {
        const itemDeposit = parseFloat(fields['보증금']) || 0;
        const depositFilter = effectiveFilters.deposit[0];
        if (depositFilter.min !== null && itemDeposit < depositFilter.min) return false;
        if (depositFilter.max !== null && itemDeposit > depositFilter.max) return false;
      }
      
      // 월세 필터
      if (effectiveFilters.rent && effectiveFilters.rent.length > 0) {
        const itemRent = parseFloat(fields['월세']) || 0;
        const rentFilter = effectiveFilters.rent[0];
        if (rentFilter.min !== null && itemRent < rentFilter.min) return false;
        if (rentFilter.max !== null && itemRent > rentFilter.max) return false;
      }
      
      // 권리금 필터
      if (effectiveFilters.premium && effectiveFilters.premium.length > 0) {
        const itemPremium = parseFloat(fields['권리금']) || 0;
        const premiumFilter = effectiveFilters.premium[0];
        if (premiumFilter.min !== null && itemPremium < premiumFilter.min) return false;
        if (premiumFilter.max !== null && itemPremium > premiumFilter.max) return false;
      }
      
      // 키워드 필터
      if (effectiveFilters.keyword && effectiveFilters.keyword.length > 0) {
        const itemText = [
          fields['가게명'] || '',
          fields['건물명'] || '',
          fields['지번'] || '',
          fields['비고'] || '',
          fields['비고3'] || ''
        ].join(' ').toLowerCase();
        
        if (!effectiveFilters.keyword.every(k => itemText.includes(k.toLowerCase()))) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  // 정렬 적용
  if (CURRENT_SORT_MODE) {
    sortListingsInPlace(filteredListings);
  }
  
  // 매물 리스트 렌더링
  renderListingList(filteredListings);
  
  // 카운트 업데이트
  updateCountsDisplay(LISTINGS.length, filteredListings.length);
}

function renderFullList() {
  const content = document.getElementById("fullListContent");
  if (!content) return;
  
  // 전체 매물 데이터 사용 (필터링되지 않은 원본)
  const allListings = LISTINGS || [];
  
  // 현재 상단 필터 적용
  const effectiveFilters = buildEffectiveFilters();
  let filteredListings = allListings;
  
  if (effectiveFilters && Object.keys(effectiveFilters).length > 0) {
    filteredListings = allListings.filter(item => {
      const fields = item.fields || {};
      
      // 지역 필터
      if (effectiveFilters.region && effectiveFilters.region.length > 0) {
        const itemRegion = fields['지역'] || '';
        if (!effectiveFilters.region.some(r => itemRegion.includes(r))) {
          return false;
        }
      }
      
      // 지번 필터
      if (effectiveFilters.jibun && effectiveFilters.jibun.length > 0) {
        const itemJibun = fields['지번'] || '';
        if (!effectiveFilters.jibun.some(j => itemJibun.includes(j))) {
          return false;
        }
      }
      
      // 건물명 필터
      if (effectiveFilters.building && effectiveFilters.building.length > 0) {
        const itemBuilding = fields['건물명'] || '';
        if (!effectiveFilters.building.some(b => itemBuilding.includes(b))) {
          return false;
        }
      }
      
      // 층수 필터
      if (effectiveFilters.floor && effectiveFilters.floor.length > 0) {
        const itemFloor = fields['층수'] || '';
        if (!effectiveFilters.floor.some(f => itemFloor.includes(f))) {
          return false;
        }
      }
      
      // 실평수 필터
      if (effectiveFilters.area && effectiveFilters.area.length > 0) {
        const itemArea = parseFloat(fields['실평수']) || 0;
        const areaFilter = effectiveFilters.area[0];
        if (areaFilter.min !== null && itemArea < areaFilter.min) return false;
        if (areaFilter.max !== null && itemArea > areaFilter.max) return false;
      }
      
      // 보증금 필터
      if (effectiveFilters.deposit && effectiveFilters.deposit.length > 0) {
        const itemDeposit = parseFloat(fields['보증금']) || 0;
        const depositFilter = effectiveFilters.deposit[0];
        if (depositFilter.min !== null && itemDeposit < depositFilter.min) return false;
        if (depositFilter.max !== null && itemDeposit > depositFilter.max) return false;
      }
      
      // 월세 필터
      if (effectiveFilters.rent && effectiveFilters.rent.length > 0) {
        const itemRent = parseFloat(fields['월세']) || 0;
        const rentFilter = effectiveFilters.rent[0];
        if (rentFilter.min !== null && itemRent < rentFilter.min) return false;
        if (rentFilter.max !== null && itemRent > rentFilter.max) return false;
      }
      
      // 권리금 필터
      if (effectiveFilters.premium && effectiveFilters.premium.length > 0) {
        const itemPremium = parseFloat(fields['권리금']) || 0;
        const premiumFilter = effectiveFilters.premium[0];
        if (premiumFilter.min !== null && itemPremium < premiumFilter.min) return false;
        if (premiumFilter.max !== null && itemPremium > premiumFilter.max) return false;
      }
      
      // 키워드 필터
      if (effectiveFilters.keyword && effectiveFilters.keyword.length > 0) {
        const itemText = [
          fields['가게명'] || '',
          fields['건물명'] || '',
          fields['지번'] || '',
          fields['비고'] || '',
          fields['비고3'] || ''
        ].join(' ').toLowerCase();
        
        if (!effectiveFilters.keyword.every(k => itemText.includes(k.toLowerCase()))) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  // 브리핑 필터 적용
  if (BRIEFING_FILTERS) {
    filteredListings = filteredListings.filter(item => {
      const status = getBriefingStatus(item.id);
      return BRIEFING_FILTERS[status];
    });
  }
  
  // 정렬 적용
  if (CURRENT_SORT_MODE) {
    sortListingsInPlace(filteredListings);
  }
  
  // 헤더 렌더링 (간단한 정보만)
  const headerHtml = `
    <div style="background: #f8f9fa; padding: 12px 16px; border-bottom: 1px solid #e0e0e0;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="color: #666; font-size: 14px;">
          총 ${allListings.length}건 / 필터 후 ${filteredListings.length}건
        </span>
      </div>
    </div>
  `;
  
  // 매물 리스트 렌더링 (테이블 형태로 모든 정보 표시)
  const listHtml = `
    <div style="height: calc(100vh - 234px); overflow-y: auto;">
      <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
        <thead style="position: sticky; top: 0; background: #f8f9fa; z-index: 10;">
          <tr style="border-bottom: 2px solid #dee2e6;">
            <th style="padding:8px;min-width:60px;">접수날짜</th>
            <th style="padding:8px;min-width:50px;">지역</th>
            <th style="padding:8px;min-width:50px;">지번</th>
            <th style="padding:8px;min-width:60px;">건물명</th>
            <th style="padding:8px;min-width:40px;">층수</th>
            <th style="padding:8px;min-width:60px;">가게명</th>
            <th style="padding:8px;min-width:40px;">분양</th>
            <th style="padding:8px;min-width:40px;">실평수</th>
            <th style="padding:8px;min-width:50px;">보증금</th>
            <th style="padding:8px;min-width:50px;">월세</th>
            <th style="padding:8px;min-width:50px;">권리금</th>
            <th style="padding:8px;min-width:300px;">비고</th>
            <th style="padding:8px;min-width:50px;">담당자</th>
            <th style="padding:8px;min-width:30px;">생</th>
            <th style="padding:8px;min-width:40px;">현황</th>
            <th style="padding:8px;min-width:50px;">지역2</th>
            <th style="padding:8px;min-width:60px;">연락처</th>
            <th style="padding:8px;min-width:50px;">의뢰인</th>
            <th style="padding:8px;min-width:120px;">비고3</th>
            <th style="padding:8px;min-width:60px;">브리핑</th>
          </tr>
        </thead>
        <tbody>
          ${filteredListings.map(item => {
            const fields = item.fields || {};
            const briefingStatus = getBriefingStatus(item.id);
            const briefingText = getBriefingStatusText(briefingStatus);
            const briefingColor = {
              [BRIEFING_STATUS.NORMAL]: '#1976d2',
              [BRIEFING_STATUS.PENDING]: '#ff9800',
              [BRIEFING_STATUS.COMPLETED]: '#4caf50',
              [BRIEFING_STATUS.ONHOLD]: '#9e9e9e'
            }[briefingStatus];
            return `
              <tr style="border-bottom:1px solid #eee;cursor:pointer;background:white;"
                  onclick="selectFullListItem('${item.id}')"
                  onmouseenter="highlightFullListItem('${item.id}', true); this.style.backgroundColor='#f8f9fa';"
                  onmouseleave="highlightFullListItem('${item.id}', false); this.style.backgroundColor='white';">
                <td style="padding:6px 8px;">${escapeHtml(fields['접수날짜'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지역'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지번'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['건물명'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['층수'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['가게명'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['분양'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['실평수'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['보증금'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['월세'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['권리금'] || '-')}</td>
                <td style="padding:6px 8px;max-width:300px;word-wrap:break-word;">${escapeHtml(fields['비고'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['담당자'] || fields['manager'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['생'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['현황'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지역2'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['연락처'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['의뢰인'] || '-')}</td>
                <td style="padding:6px 8px;max-width:120px;word-wrap:break-word;">${escapeHtml(fields['비고3'] || '-')}</td>
                <td style="padding:6px 8px;text-align:center;">
                  <div style="padding:2px 6px;border-radius:8px;font-size:12px;font-weight:600;color:white;background:${briefingColor};cursor:pointer;display:inline-block;"
                       onclick="event.stopPropagation(); cycleBriefingStatus('${item.id}')">
                    ${briefingText}
                  </div>
                </td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    </div>
  `;
  
  content.innerHTML = headerHtml + listHtml;
}
function renderFullBriefingList() {
  const content = document.getElementById("fullBriefingListContent");
  if (!content) return;
  
  // 브리핑 현황이 체크된 매물만 필터링
  const briefingListings = LISTINGS.filter(item => {
    const status = getBriefingStatus(item.id);
    return status !== BRIEFING_STATUS.NORMAL; // 일반이 아닌 모든 상태 (예정, 완료, 보류)
  });
  
  // 현재 상단 필터 적용
  const effectiveFilters = buildEffectiveFilters();
  let filteredListings = briefingListings;
  
  if (effectiveFilters && Object.keys(effectiveFilters).length > 0) {
    filteredListings = briefingListings.filter(item => {
      const fields = item.fields || {};
      
      // 지역 필터
      if (effectiveFilters.region && effectiveFilters.region.length > 0) {
        const itemRegion = fields['지역'] || '';
        if (!effectiveFilters.region.some(r => itemRegion.includes(r))) {
          return false;
        }
      }
      
      // 지번 필터
      if (effectiveFilters.jibun && effectiveFilters.jibun.length > 0) {
        const itemJibun = fields['지번'] || '';
        if (!effectiveFilters.jibun.some(j => itemJibun.includes(j))) {
          return false;
        }
      }
      
      // 건물명 필터
      if (effectiveFilters.building && effectiveFilters.building.length > 0) {
        const itemBuilding = fields['건물명'] || '';
        if (!effectiveFilters.building.some(b => itemBuilding.includes(b))) {
          return false;
        }
      }
      
      // 층수 필터
      if (effectiveFilters.floor && effectiveFilters.floor.length > 0) {
        const itemFloor = fields['층수'] || '';
        if (!effectiveFilters.floor.some(f => itemFloor.includes(f))) {
          return false;
        }
      }
      
      // 실평수 필터
      if (effectiveFilters.area && effectiveFilters.area.length > 0) {
        const itemArea = parseFloat(fields['실평수']) || 0;
        const areaFilter = effectiveFilters.area[0];
        if (areaFilter.min !== null && itemArea < areaFilter.min) return false;
        if (areaFilter.max !== null && itemArea > areaFilter.max) return false;
      }
      
      // 보증금 필터
      if (effectiveFilters.deposit && effectiveFilters.deposit.length > 0) {
        const itemDeposit = parseFloat(fields['보증금']) || 0;
        const depositFilter = effectiveFilters.deposit[0];
        if (depositFilter.min !== null && itemDeposit < depositFilter.min) return false;
        if (depositFilter.max !== null && itemDeposit > depositFilter.max) return false;
      }
      
      // 월세 필터
      if (effectiveFilters.rent && effectiveFilters.rent.length > 0) {
        const itemRent = parseFloat(fields['월세']) || 0;
        const rentFilter = effectiveFilters.rent[0];
        if (rentFilter.min !== null && itemRent < rentFilter.min) return false;
        if (rentFilter.max !== null && itemRent > rentFilter.max) return false;
      }
      
      // 권리금 필터
      if (effectiveFilters.premium && effectiveFilters.premium.length > 0) {
        const itemPremium = parseFloat(fields['권리금']) || 0;
        const premiumFilter = effectiveFilters.premium[0];
        if (premiumFilter.min !== null && itemPremium < premiumFilter.min) return false;
        if (premiumFilter.max !== null && itemPremium > premiumFilter.max) return false;
      }
      
      // 키워드 필터
      if (effectiveFilters.keyword && effectiveFilters.keyword.length > 0) {
        const itemText = [
          fields['가게명'] || '',
          fields['건물명'] || '',
          fields['지번'] || '',
          fields['비고'] || '',
          fields['비고3'] || ''
        ].join(' ').toLowerCase();
        
        if (!effectiveFilters.keyword.every(k => itemText.includes(k.toLowerCase()))) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  // 정렬 적용
  if (CURRENT_SORT_MODE) {
    sortListingsInPlace(filteredListings);
  }
  
  // 헤더 렌더링 (간단한 정보만)
  const headerHtml = `
    <div style="background: #f8f9fa; padding: 12px 16px; border-bottom: 1px solid #e0e0e0;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="color: #666; font-size: 14px;">
          총 ${LISTINGS.length}건 / 브리핑 ${briefingListings.length}건 / 필터 후 ${filteredListings.length}건
        </span>
      </div>
    </div>
  `;
  
  // 매물 리스트 렌더링 (테이블 형태로 모든 정보 표시)
  const listHtml = `
    <div style="height: calc(100vh - 234px); overflow-y: auto;">
      <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
        <thead style="position: sticky; top: 0; background: #f8f9fa; z-index: 10;">
          <tr style="border-bottom: 2px solid #dee2e6;">
            <th style="padding:8px;min-width:60px;">접수날짜</th>
            <th style="padding:8px;min-width:50px;">지역</th>
            <th style="padding:8px;min-width:50px;">지번</th>
            <th style="padding:8px;min-width:60px;">건물명</th>
            <th style="padding:8px;min-width:40px;">층수</th>
            <th style="padding:8px;min-width:60px;">가게명</th>
            <th style="padding:8px;min-width:40px;">분양</th>
            <th style="padding:8px;min-width:40px;">실평수</th>
            <th style="padding:8px;min-width:50px;">보증금</th>
            <th style="padding:8px;min-width:50px;">월세</th>
            <th style="padding:8px;min-width:50px;">권리금</th>
            <th style="padding:8px;min-width:300px;">비고</th>
            <th style="padding:8px;min-width:50px;">담당자</th>
            <th style="padding:8px;min-width:30px;">생</th>
            <th style="padding:8px;min-width:40px;">현황</th>
            <th style="padding:8px;min-width:50px;">지역2</th>
            <th style="padding:8px;min-width:60px;">연락처</th>
            <th style="padding:8px;min-width:50px;">의뢰인</th>
            <th style="padding:8px;min-width:120px;">비고3</th>
            <th style="padding:8px;min-width:60px;">브리핑</th>
          </tr>
        </thead>
        <tbody>
          ${filteredListings.map(item => {
            const fields = item.fields || {};
            const briefingStatus = getBriefingStatus(item.id);
            const briefingText = getBriefingStatusText(briefingStatus);
            const briefingColor = {
              [BRIEFING_STATUS.NORMAL]: '#1976d2',
              [BRIEFING_STATUS.PENDING]: '#ff9800',
              [BRIEFING_STATUS.COMPLETED]: '#4caf50',
              [BRIEFING_STATUS.ONHOLD]: '#9e9e9e'
            }[briefingStatus];
            return `
              <tr style="border-bottom:1px solid #eee;cursor:pointer;background:white;"
                  onclick="selectFullListItem('${item.id}')"
                  onmouseenter="highlightFullListItem('${item.id}', true); this.style.backgroundColor='#f8f9fa';"
                  onmouseleave="highlightFullListItem('${item.id}', false); this.style.backgroundColor='white';">
                <td style="padding:6px 8px;">${escapeHtml(fields['접수날짜'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지역'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지번'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['건물명'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['층수'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['가게명'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['분양'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['실평수'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['보증금'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['월세'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['권리금'] || '-')}</td>
                <td style="padding:6px 8px;max-width:300px;word-wrap:break-word;">${escapeHtml(fields['비고'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['담당자'] || fields['manager'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['생'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['현황'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['지역2'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['연락처'] || '-')}</td>
                <td style="padding:6px 8px;">${escapeHtml(fields['의뢰인'] || '-')}</td>
                <td style="padding:6px 8px;max-width:120px;word-wrap:break-word;">${escapeHtml(fields['비고3'] || '-')}</td>
                <td style="padding:6px 8px;text-align:center;">
                  <div style="padding:2px 6px;border-radius:8px;font-size:12px;font-weight:600;color:white;background:${briefingColor};cursor:pointer;display:inline-block;"
                       onclick="event.stopPropagation(); cycleBriefingStatus('${item.id}')">
                    ${briefingText}
                  </div>
                </td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    </div>
  `;
  
  content.innerHTML = headerHtml + listHtml;
}



function selectFullListItem(listingId) {
  // 매물 상세 정보 표시
  const item = LISTINGS.find(l => l.id === listingId);
  if (item) {
    // 지도에서 해당 매물 선택
    setActiveMarker(listingId);
    // 매물 상세 정보 표시
    renderDetailPanel(item);
  }
}

function highlightFullListItem(listingId, on) {
  // 지도에서 해당 매물 하이라이트
  highlightMarkerTemp(listingId, on);
}

function refreshFullList() {
  // 전체보기 패널이 열려있을 때만 새로고침
  if (UI_STATE.showFullList) {
    renderFullList();
  }
}

function toggleBriefingFilter() {
  const dropdown = document.getElementById('briefingFilterDropdown');
  if (dropdown) {
    dropdown.classList.toggle('hidden');
  }
}

// 브리핑 필터 드롭다운 외부 클릭 시 닫기
document.addEventListener('click', function(event) {
  const briefingFilter = document.getElementById('briefingFilter');
  const dropdown = document.getElementById('briefingFilterDropdown');
  
  if (briefingFilter && dropdown && !briefingFilter.contains(event.target)) {
    dropdown.classList.add('hidden');
  }
});

function renderDetailPanel(item) {
  // showSecondaryPanel 함수 사용
  showSecondaryPanel('viewListingDetail');
  
  const viewListingDetail = document.getElementById('viewListingDetail');
  if (!viewListingDetail) {
    console.error('매물상세 뷰 요소를 찾을 수 없습니다');
    return;
  }
  
  const detailTitleEl = document.getElementById("secondaryPanelTitle");
  const detailEl = document.getElementById('viewListingDetail');
  
  if (!detailTitleEl || !detailEl) return;
  
  detailTitleEl.textContent = "매물 상세 정보";
  
  const fields = item.fields || {};
  const addr = item.address_full || '';
  
  detailEl.innerHTML = `
    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
      <div style="font-size: 16px; font-weight: bold; color: #333; margin-bottom: 6px;">${escapeHtml(fields['가게명'] || fields['건물명'] || '매물명 없음')}</div>
      <div style="color: #666; font-size: 13px;">📍 ${escapeHtml(addr || '주소 없음')} <span class="listing-detail-briefing-status briefing-${getBriefingStatus(item.id)}" onclick="cycleBriefingStatus('${item.id}')">${getBriefingStatusText(getBriefingStatus(item.id))}</span></div>
    </div>
    
    <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; height: calc(100vh - 200px); overflow-y: auto;">
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">접수날짜</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['접수날짜'] || '접수날짜 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">지역</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['지역'] || '지역 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">지번</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['지번'] || '지번 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">건물명</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['건물명'] || '건물명 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">가게명</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['가게명'] || '가게명 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">층수</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['층수'] || '층수 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">실평수</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['실평수'] || '실평수 정보 없음')}평</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">보증금</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['보증금'] || '보증금 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">월세</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['월세'] || '월세 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">권리금</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['권리금'] || '권리금 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">비고</span>
        <span class="value" style="color: #666; flex: 1; font-size: 13px;">${escapeHtml(fields['비고'] || '비고 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">의뢰인</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['의뢰인'] || '의뢰인 정보 없음')}</span>
      </div>
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">연락처</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['연락처'] || '연락처 정보 없음')}</span>
      </div>
      ${fields['비고3'] ? `<div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">비고3</span>
        <span class="value" style="color: #666; flex: 1; font-size: 13px;">${escapeHtml(fields['비고3'])}</span>
      </div>` : ''}
      <div class="detail-row" style="display: flex; justify-content: space-between; padding: 6px 0;">
        <span class="label" style="font-weight: 600; color: #333; min-width: 70px; font-size: 13px;">담당자</span>
        <span class="value" style="color: #666; font-size: 13px;">${escapeHtml(fields['담당자'] || fields['manager'] || '담당자 정보 없음')}</span>
      </div>
    </div>
  `;
}

/**************************************
 * ===== 지도 초기화 =====
 **************************************/
function initMap() {
  console.log("🔍 initMap 호출됨");
  console.log("window.naver:", window.naver);
  console.log("window.naver.maps:", window.naver?.maps);
  
  // 네이버 지도 API가 완전히 로드되었는지 확인
  if (!window.naver || !window.naver.maps || typeof naver.maps.Map !== 'function') {
    console.log("[initMap] window.naver.maps가 아직 완전히 로드되지 않았습니다. 500ms 후 재시도");
    
    // 무한 루프 방지: 최대 5번만 재시도
    if (!window.initMapRetryCount) {
      window.initMapRetryCount = 0;
    }
    
    if (window.initMapRetryCount < 5) {
      window.initMapRetryCount++;
      console.log(`🔄 재시도 ${window.initMapRetryCount}/5`);
      setTimeout(initMap, 500);
    } else {
      console.error("❌ 네이버 지도 API 로드 실패 - 최대 재시도 횟수 초과");
      showToast("네이버 지도 API를 로드할 수 없습니다. 페이지를 새로고침해주세요.", "error");
      // 재시도 카운터 리셋
      window.initMapRetryCount = 0;
    }
    return;
  }
  
  // 성공적으로 로드되면 재시도 카운터 리셋
  window.initMapRetryCount = 0;

  dbg("initMap 호출");
  
  // MarkerClustering.js 동적 로드
  loadMarkerClustering();

  MAP = new naver.maps.Map('map', {
    center: new naver.maps.LatLng(37.4933485, 126.7225676),
    zoom: 18,
    mapTypeControl: false
  });

  naver.maps.Event.addListener(MAP, 'click', (e) => {
    // 거리제기 모드일 때는 다른 동작 수행
    if (IS_DISTANCE_MODE) {
      handleDistanceClick(e);
      return;
    }
    
    // 거리뷰 레이어가 활성화된 경우 클릭 이벤트 처리
    if (MAP._streetLayer) {
      console.log('📍 지도 클릭 (거리뷰 레이어 활성화됨):', e.coord);
      console.log('🔄 거리뷰 레이어 클릭 이벤트 시뮬레이션');
      
      // 거리뷰 레이어 클릭 이벤트를 직접 호출
      if (e.coord) {
        console.log('🔄 openPanorama 함수 호출 시작');
        openPanorama(e.coord);
      }
      return;
    }
    
    // 기존 동작
    hideClusterList();
    const secondaryPanel = document.getElementById('secondaryPanel');
    if (secondaryPanel) {
      secondaryPanel.classList.add('hidden');
      secondaryPanel.classList.remove('visible');
    }
    clearSelection();
  });
  
  // 거리제기 더블클릭 이벤트
  naver.maps.Event.addListener(MAP, 'dblclick', (e) => {
    if (IS_DISTANCE_MODE) {
      handleDistanceDoubleClick(e);
    }
  });
  
  // 거리제기 우클릭 이벤트 (삭제)
  naver.maps.Event.addListener(MAP, 'rightclick', (e) => {
    if (IS_DISTANCE_MODE && DISTANCE_POINTS.length > 0) {
      handleDistanceRightClick(e);
    }
  });

  setLayoutHeight();
  naver.maps.Event.trigger(MAP, 'resize');

  MAP_READY = true;
  while (MAP_READY_QUEUE.length > 0) {
    try {
      const fn = MAP_READY_QUEUE.shift();
      fn && fn();
    } catch (err) {
      console.error('[MAP_READY_QUEUE] 실행 중 오류', err);
    }
  }

  naver.maps.Event.addListener(MAP, 'idle', () => {
    if (!MAP_READY) return;

    const zoom = MAP.getZoom();
    const THRESHOLD = 14;
    if (zoom < THRESHOLD) {
      if (UI_STATE.isBriefingListMode) {
        renderBriefingList();
      } else {
        renderListingList([]);
      }
      updateCountsDisplay(LISTINGS.length, 0);
      return;
    }

    const bounds = MAP.getBounds();
    const visibleItems = FILTERED_LISTINGS.filter(item => {
      const { lat, lng } = item.coords || {};
      return lat != null && lng != null
        && bounds.hasLatLng(new naver.maps.LatLng(lat, lng));
    });
    
    sortListingsInPlace(visibleItems);
    
    // 브리핑리스트 모드일 때는 브리핑리스트를 렌더링, 아니면 일반 매물리스트
    if (UI_STATE.isBriefingListMode) {
      renderBriefingList();
    } else {
      renderListingList(visibleItems);
    }
    
    updateCountsDisplay(FILTERED_LISTINGS.length, visibleItems.length);
  });

  document.dispatchEvent(new Event('map-ready'));
  
  // 클러스터 클릭 위임 바인딩
  setTimeout(() => {
    bindClusterClickDelegation();
  }, 500);
  
  // 추가로 마커가 배치된 후에도 바인딩
  setTimeout(() => {
    bindClusterClickDelegation();
  }, 1000);
  
  // 지도 컨트롤 초기화
  initMapControls();
}
/**************************************
 * ===== 세션 사용자 동기화 =====
 **************************************/
async function syncUserFromSession() {
  try {
    // 현재 사용자 정보 가져오기
    const currentUserEmail = localStorage.getItem("X-USER");
    
    const headers = { "Accept": "application/json" };
    if (currentUserEmail) {
      headers["X-User"] = currentUserEmail;
    }
    
    const res = await fetch("/api/me", { headers: headers });
    const data = await res.json();

    if (res.ok && data && data.logged_in && data.email) {
      setCurrentUser(data.email);

      // 어드민 권한 정보 저장
      if (data.is_admin) {
        localStorage.setItem("X-USER-ADMIN", "true");
        console.log("✅ 어드민 권한 확인됨:", data.email);
      } else {
        localStorage.removeItem("X-USER-ADMIN");
        console.log("ℹ️ 일반 사용자:", data.email);
      }

      const usEl = document.getElementById('userStatus');
      if (usEl) {
        const roleText = data.is_admin ? `어드민: ${data.email}` : `사용자: ${data.email}`;
        usEl.textContent = roleText;
      }
      
      const nl = document.getElementById('naverLoginBtn');
      const lo = document.getElementById('logoutBtn');
      if (nl) nl.classList.add('hidden');
      if (lo) lo.classList.remove('hidden');

      const roleNameEl = document.getElementById("userRoleName");
      if (roleNameEl && data.role && data.name) {
        roleNameEl.textContent = `${data.role} / ${data.name}`;
      }

      // 어드민 UI 토글
      if (typeof toggleAdminUI === 'function') {
        toggleAdminUI(data.is_admin);
      }

      return;
    }

    const stored = localStorage.getItem("X-USER");
    if (stored) {
      setCurrentUser(stored);
      return;
    }

    currentUser = null;
    const usEl = document.getElementById('userStatus');
    if (usEl) usEl.textContent = '비로그인';
    const nl = document.getElementById('naverLoginBtn');
    const lo = document.getElementById('logoutBtn');
    if (nl) nl.classList.remove('hidden');
    if (lo) lo.classList.add('hidden');

  } catch (e) {
    console.error("사용자 세션 로드 실패", e);
    const stored = localStorage.getItem("X-USER");
    if (stored) {
      setCurrentUser(stored);
    }
  }
}

async function loadCustomerList(filter = 'own') {
  try {
    if (!currentUser) {
      console.error('사용자가 로그인되지 않았습니다.');
      return;
    }
    
    let url = '/api/customers';
    
    // 필터링 파라미터 추가
    if (filter === 'own') {
      url += '?filter=own';
    } else if (filter === 'all') {
      url += '?filter=all';
    } else if (filter.startsWith('manager:')) {
      const manager = filter.split(':')[1];
      url += `?filter=manager&manager=${encodeURIComponent(manager)}`;
    }
    
    console.log('🌐 API 요청 URL:', url);
    console.log('👤 현재 사용자:', currentUser);
    
    const res = await fetch(url, {
      headers: {
        'X-User': currentUser
      }
    });
    
    console.log('📡 응답 상태:', res.status, res.statusText);
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    console.log('📦 받은 데이터:', data);
    console.log('📋 data.items:', data.items);
    console.log('📋 data.itema:', data.itema);
    console.log('📋 data 키들:', Object.keys(data));
    
    const customerList = data.items || data.itema || [];
    console.log('📋 최종 고객 목록:', customerList);
    
    // 각 고객 객체의 속성 확인
    if (customerList.length > 0) {
      console.log('🔍 첫 번째 고객 객체:', customerList[0]);
      console.log('🔍 첫 번째 고객의 속성들:', Object.keys(customerList[0]));
      console.log('🔍 첫 번째 고객의 name:', customerList[0].name);
      console.log('🔍 첫 번째 고객의 phone:', customerList[0].phone);
    }
    
    console.log('🚀 renderCustomerList 호출 직전 customerList:', customerList);
    console.log('🚀 renderCustomerList 호출 직전 첫 번째 고객:', customerList[0]);
    
    renderCustomerList(customerList);
  } catch (err) {
    console.error('고객 목록 요청 중 예외 발생:', err);
  }
}

function renderCustomerList(list) {
  console.log('🔍 renderCustomerList 호출:', list);
  console.log('🔍 renderCustomerList 매개변수 타입:', typeof list);
  console.log('🔍 renderCustomerList 매개변수 길이:', list ? list.length : 'undefined');
  console.log('🔍 고객 ID 목록:', list.map(c => c.id));
  console.log('🔍 첫 번째 고객 상세:', list[0]);
  console.log('🔍 첫 번째 고객 타입:', typeof list[0]);
  console.log('🔍 첫 번째 고객 키들:', list[0] ? Object.keys(list[0]) : 'undefined');
  
  // 전역 변수에 고객 목록 저장 (수정/삭제 기능용)
  window.currentCustomerList = list;
  console.log('🔍 window.currentCustomerList 설정 후:', window.currentCustomerList);
  console.log('🔍 window.currentCustomerList 첫 번째 고객:', window.currentCustomerList[0]);
  
  // 2차 사이드바의 고객 목록 컨테이너를 찾기
  let customerListContent = document.getElementById("customerListContent2");
  if (!customerListContent) {
    // viewCustomerList 내부에서 찾기
    const viewCustomerList = document.getElementById("viewCustomerList");
    if (viewCustomerList) {
      customerListContent = viewCustomerList.querySelector(".customer-list-container div");
    }
  }
  if (!customerListContent) {
    customerListContent = document.getElementById("customerListContent");
  }
  
  if (!customerListContent) {
    console.error("고객 목록 컨테이너를 찾을 수 없습니다.");
    return;
  }
  
  // 고객 목록을 카드 형태로 렌더링
  customerListContent.innerHTML = '';
  
  if (list.length === 0) {
    customerListContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">등록된 고객이 없습니다.</div>';
    return;
  }
  
  // 필터 영역을 같은 줄에 배치
  const titleContainer = document.createElement('div');
  titleContainer.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 0 4px;';
  
  // 필터 영역
  const filterContainer = document.createElement('div');
  filterContainer.style.cssText = 'display: flex; gap: 8px; align-items: center;';
  
  // 담당자 필터 (어드민인 경우만)
  if (currentUser === 'darkbirth@naver.com' || currentUser === 'darkbirth1@gmail.com' || currentUser === 'jeonghannah@naver.com') {
    const managerFilter = document.createElement('select');
    managerFilter.id = 'customerFilterSelect';
    managerFilter.style.cssText = 'padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; min-width: 100px;';
    managerFilter.innerHTML = '<option value="all">전체 고객</option>';
    
    // 담당자 목록을 동적으로 가져오기
    fetch('/api/customers/managers', {
      headers: { 'X-User': currentUser }
    })
    .then(response => response.json())
    .then(data => {
      if (data.managers && data.managers.length > 0) {
        data.managers.forEach(manager => {
          const option = document.createElement('option');
          option.value = `manager:${manager}`;
          option.textContent = `${manager} 고객`;
          managerFilter.appendChild(option);
        });
      }
    })
    .catch(error => {
      console.error('담당자 목록 가져오기 실패:', error);
    });
    
    managerFilter.addEventListener('change', handleCustomerFilterChange);
    filterContainer.appendChild(managerFilter);
  }
  
  // 상태 필터 (모든 사용자)
  const statusFilter = document.createElement('select');
  statusFilter.id = 'customerStatusFilter';
  statusFilter.style.cssText = 'padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; min-width: 70px;';
  statusFilter.innerHTML = `
    <option value="all">전체 상태</option>
    <option value="생">생성</option>
    <option value="완">완료</option>
    <option value="보류">보류</option>
    <option value="포기">포기</option>
  `;
  statusFilter.addEventListener('change', handleStatusFilterChange);
  filterContainer.appendChild(statusFilter);
  
  titleContainer.appendChild(filterContainer);
  customerListContent.appendChild(titleContainer);
  
  // 고객 목록 렌더링
  renderCustomerListItems(list);
};

// 필터링된 고객 목록만 렌더링 (필터는 유지)
function renderFilteredCustomerList(filteredList) {
  // 고객 목록 컨테이너를 찾기
  let customerListContent = document.getElementById("customerListContent2");
  if (!customerListContent) {
    const viewCustomerList = document.getElementById("viewCustomerList");
    if (viewCustomerList) {
      customerListContent = viewCustomerList.querySelector(".customer-list-container div");
    }
  }
  if (!customerListContent) {
    customerListContent = document.getElementById("customerListContent");
  }
  
  if (!customerListContent) {
    console.error("고객 목록 컨테이너를 찾을 수 없습니다.");
    return;
  }
  
  // 기존 고객 목록 컨테이너 제거 (필터는 유지)
  const existingListContainer = customerListContent.querySelector('.customer-list-items');
  if (existingListContainer) {
    existingListContainer.remove();
  }
  
  // 필터링된 목록 렌더링
  renderCustomerListItems(filteredList);
};

// 고객 목록 아이템만 렌더링
function renderCustomerListItems(list) {
  // 고객 목록 컨테이너를 찾기
  let customerListContent = document.getElementById("customerListContent2");
  if (!customerListContent) {
    const viewCustomerList = document.getElementById("viewCustomerList");
    if (viewCustomerList) {
      customerListContent = viewCustomerList.querySelector(".customer-list-container div");
    }
  }
  if (!customerListContent) {
    customerListContent = document.getElementById("customerListContent");
  }
  
  if (!customerListContent) {
    console.error("고객 목록 컨테이너를 찾을 수 없습니다.");
    return;
  }
  
  // 고객 목록 컨테이너
  const listContainer = document.createElement('div');
  listContainer.className = 'customer-list-items';
  listContainer.style.cssText = 'height: auto; overflow: visible; padding-right: 4px;';
  
  list.forEach((c, index) => {
    console.log(`🔍 고객 ${index + 1} 렌더링:`, c);
    console.log(`🔍 고객 ${index + 1} 이름:`, c.name);
    console.log(`🔍 고객 ${index + 1} 전화번호:`, c.phone);
    
    const customerCard = document.createElement('div');
    customerCard.className = 'customer-card';
    customerCard.style.cssText = `
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 8px;
      background: white;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    `;
    
    // 더블클릭 안내 툴팁 추가
    customerCard.title = "클릭: 상세보기 | 더블클릭: 필터적용 | 우클릭: 메뉴 (수정/상태변경/삭제)";
    
    // 고객 정보 요약
    const summary = [];
    if (c.regions) summary.push(`📍 ${c.regions}`);
    if (c.floor) summary.push(`🏢 ${c.floor}층`);
    if (c.area) summary.push(`📐 ${c.area}평`);
    if (c.deposit) summary.push(`💰 보:${c.deposit}`);
    if (c.rent) summary.push(`💵 월:${c.rent}`);
    if (c.premium) summary.push(`🔑 권:${c.premium}`);
    
    // 참고사항 처리 (긴 경우 줄임)
    let notesDisplay = '';
    if (c.notes && c.notes.trim()) {
      const notes = c.notes.trim();
      notesDisplay = notes.length > 30 ? notes.substring(0, 30) + '...' : notes;
    }
    
    // 상태 표시 (클릭 가능한 드롭다운)
    const status = c.status || '생';
    const statusConfig = {
      '생': { label: '생성', color: '#28a745', bgColor: '#d4edda' },
      '완': { label: '완료', color: '#0c5460', bgColor: '#d1ecf1' },
      '보류': { label: '보류', color: '#856404', bgColor: '#fff3cd' },
      '포기': { label: '포기', color: '#721c24', bgColor: '#f8d7da' }
    };
    const statusInfo = statusConfig[status] || statusConfig['생'];
    
    customerCard.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px;">
        <div style="font-weight: bold; color: #333; font-size: 14px;">${escapeHtml(c.name || '이름 없음')}</div>
        <div style="display: flex; align-items: center; gap: 4px;">
          <span style="color: #666; font-size: 11px;">👤 ${escapeHtml(c.manager || '담당자 없음')}</span>
          <span class="status-badge" 
                style="background: ${statusInfo.bgColor}; color: ${statusInfo.color}; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold; cursor: pointer; transition: all 0.2s ease;"
                onclick="event.stopPropagation(); showStatusDropdown(event, '${c.id}', '${status}')"
                title="클릭하여 상태 변경">${statusInfo.label}</span>
        </div>
      </div>
      <div style="color: #666; font-size: 12px; margin-bottom: 3px;">📞 ${escapeHtml(c.phone || '연락처 없음')}</div>
      <div style="color: #666; font-size: 11px; line-height: 1.2; margin-bottom: 3px;">
        ${summary.length > 0 ? summary.join(' | ') : '희망 조건 없음'}
      </div>
      ${notesDisplay ? `<div style="color: #888; font-size: 10px; line-height: 1.1; font-style: italic;">📝 ${escapeHtml(notesDisplay)}</div>` : ''}
    `;
    
    customerCard.addEventListener('click', (e) => {
      // 상태 배지 클릭이 아닌 경우에만 고객 상세보기 실행
      if (!e.target.classList.contains('status-badge')) {
        showCustomerDetail(c);
      }
    });
    
    // 더블클릭 시 필터 적용
    customerCard.addEventListener('dblclick', () => {
      applyCustomerFilter(c);
    });
    
    // 우클릭 컨텍스트 메뉴 추가
    customerCard.addEventListener('contextmenu', (e) => {
      console.log('🖱️ 우클릭 이벤트 발생:', e);
      console.log('🖱️ 우클릭한 고객:', c);
      e.preventDefault();
      showCustomerContextMenu(e, c);
    });
    
    customerCard.addEventListener('mouseenter', () => {
      customerCard.style.backgroundColor = '#f0f8ff';
      customerCard.style.borderColor = '#1976d2';
      customerCard.style.boxShadow = '0 2px 4px rgba(25, 118, 210, 0.1)';
    });
    
    customerCard.addEventListener('mouseleave', () => {
      customerCard.style.backgroundColor = 'white';
      customerCard.style.borderColor = '#e0e0e0';
      customerCard.style.boxShadow = 'none';
    });
    
    // 상태 배지 호버 효과 추가
    const statusBadge = customerCard.querySelector('.status-badge');
    if (statusBadge) {
      statusBadge.addEventListener('mouseenter', () => {
        statusBadge.style.transform = 'scale(1.05)';
        statusBadge.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
      });
      
      statusBadge.addEventListener('mouseleave', () => {
        statusBadge.style.transform = 'scale(1)';
        statusBadge.style.boxShadow = 'none';
      });
    }
    
    listContainer.appendChild(customerCard);
  });
  
  customerListContent.appendChild(listContainer);
}

// 고객 컨텍스트 메뉴 표시
function showCustomerContextMenu(e, customer) {
  console.log('📋 showCustomerContextMenu 호출:', customer);
  console.log('📋 고객 ID:', customer.id);
  
  // 기존 컨텍스트 메뉴 제거
  const existingMenu = document.getElementById('customerContextMenu');
  if (existingMenu) {
    existingMenu.remove();
  }
  
  // 새 컨텍스트 메뉴 생성
  const contextMenu = document.createElement('div');
  contextMenu.id = 'customerContextMenu';
  contextMenu.style.cssText = `
    position: fixed;
    top: ${e.clientY}px;
    left: ${e.clientX}px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    z-index: 999999;
    min-width: 120px;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
  `;
  
  console.log('📋 컨텍스트 메뉴 HTML 생성 중...');
  contextMenu.innerHTML = `
    <div class="context-menu-item" data-action="edit" data-customer-id="${customer.id}" style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;">✏️ 수정</div>
    <div class="context-menu-item" data-action="status" data-customer-id="${customer.id}" style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;">🔄 상태변경</div>
    <div class="context-menu-item" data-action="delete" data-customer-id="${customer.id}" style="padding: 8px 12px; cursor: pointer; font-size: 13px; color: #dc3545;">🗑️ 삭제</div>
  `;
  console.log('📋 컨텍스트 메뉴 HTML 생성 완료');
  
  // 호버 효과 및 클릭 이벤트
  const menuItems = contextMenu.querySelectorAll('.context-menu-item');
  menuItems.forEach(item => {
    item.addEventListener('mouseenter', () => {
      item.style.backgroundColor = '#f5f5f5';
    });
    item.addEventListener('mouseleave', () => {
      item.style.backgroundColor = 'white';
    });
    
    // 클릭 이벤트 추가
    item.addEventListener('click', async (e) => {
      e.stopPropagation();
      const action = item.getAttribute('data-action');
      const customerId = item.getAttribute('data-customer-id');
      console.log('🖱️ 컨텍스트 메뉴 클릭:', action, customerId);
      
      if (action === 'edit') {
        console.log('🔧 editCustomerById 함수 호출 시도:', customerId);
        console.log('🔧 editCustomerById 함수 존재 여부:', typeof window.editCustomerById);
        if (typeof window.editCustomerById === 'function') {
          console.log('🔧 editCustomerById 함수 호출 직전');
          console.log('🔧 customerId 값:', customerId);
          console.log('🔧 window.editCustomerById 함수:', window.editCustomerById);
          try {
            const result = await window.editCustomerById(customerId);
            console.log('🔧 editCustomerById 함수 호출 완료, 결과:', result);
          } catch (error) {
            console.error('❌ editCustomerById 함수 실행 중 오류:', error);
          }
        } else {
          console.error('❌ editCustomerById 함수를 찾을 수 없습니다!');
        }
      } else if (action === 'status') {
        console.log('🔄 changeCustomerStatusById 함수 호출 시도:', customerId);
        if (typeof window.changeCustomerStatusById === 'function') {
          window.changeCustomerStatusById(customerId);
        } else {
          console.error('❌ changeCustomerStatusById 함수를 찾을 수 없습니다!');
        }
      } else if (action === 'delete') {
        console.log('🗑️ deleteCustomerById 함수 호출 시도:', customerId);
        if (typeof window.deleteCustomerById === 'function') {
          window.deleteCustomerById(customerId);
        } else {
          console.error('❌ deleteCustomerById 함수를 찾을 수 없습니다!');
        }
      }
      
      contextMenu.remove();
    });
  });
  
  document.body.appendChild(contextMenu);
  console.log('📋 컨텍스트 메뉴 DOM에 추가 완료');
  console.log('📋 컨텍스트 메뉴 위치:', e.clientX, e.clientY);
  
  // 다른 곳 클릭 시 메뉴 닫기
  setTimeout(() => {
    document.addEventListener('click', function closeMenu() {
      contextMenu.remove();
      document.removeEventListener('click', closeMenu);
    });
  }, 100);
}
// 고객 수정 함수
window.editCustomerById = async function(customerId) {
  console.log('🔧 editCustomer 호출:', customerId);
  console.log('👤 현재 사용자:', currentUser);
  console.log('🔍 현재 고객 목록:', window.currentCustomerList);
  console.log('🔍 찾을 고객 ID:', customerId);
  
  try {
    // 현재 로드된 고객 목록에서 고객 데이터 찾기
    const customer = window.currentCustomerList.find(c => c.id === customerId);
    console.log('🔍 현재 고객 목록에서 찾은 고객:', customer);
    
    if (!customer) {
      console.error('❌ 고객을 찾을 수 없습니다:', customerId);
      alert('고객 정보를 찾을 수 없습니다.');
      return;
    }
    
    console.log('✅ 고객 데이터 찾음:', customer);
    
    // 현재 선택된 고객 저장 (취소 버튼용)
    window.selectedCustomer = customer;
    
    // 수정 전용 패널 열기
    showSecondaryPanel('viewCustomerEdit');
    renderCustomerEditForm(customer);
    
    // 제목 변경
    const detailTitleEl = document.getElementById("secondaryPanelTitle");
    if (detailTitleEl) {
      detailTitleEl.textContent = "고객 정보 수정";
    }
  } catch (error) {
    console.error('고객 정보 가져오기 중 오류:', error);
    alert('고객 정보를 가져오는 중 오류가 발생했습니다.');
  }
}

// 고객 삭제 함수
window.deleteCustomerById = async function(customerId) {
  console.log('🗑️ deleteCustomer 호출:', customerId);
  console.log('👤 현재 사용자:', currentUser);
  
  if (!confirm('정말로 이 고객을 삭제하시겠습니까?')) {
    return;
  }
  
  try {
    const url = `/api/customers/${customerId}`;
    console.log('🌐 요청 URL:', url);
    
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'X-User': currentUser
      }
    });
    
    console.log('📡 응답 상태:', response.status, response.statusText);
    
    if (response.ok) {
      showToast('고객이 삭제되었습니다.', 'success');
      // 고객 목록 새로고침
      loadCustomerList();
    } else {
      const error = await response.text();
      console.error('❌ 삭제 실패:', error);
      alert(`삭제 실패: ${error}`);
    }
  } catch (error) {
    console.error('고객 삭제 중 오류:', error);
    alert('고객 삭제 중 오류가 발생했습니다.');
  }
}

// 고객 ID로 고객 데이터 가져오기
function getCustomerById(customerId) {
  // 현재 로드된 고객 목록에서 찾기
  // 실제로는 서버에서 다시 가져오는 것이 좋지만, 간단히 구현
  return window.currentCustomerList ? window.currentCustomerList.find(c => c.id === customerId) : null;
}

// 고객 선택 초기화
function clearCustomerSelection() {
  // 선택된 고객 초기화
  window.selectedCustomer = null;
  
  // 브리핑 상태 초기화
  loadBriefingStates(null);
  
  // 브리핑 리스트 모드 해제하고 매물리스트로 기본 설정
  UI_STATE.isBriefingListMode = false;
  UI_STATE.currentCustomerId = null;
  
  // 버튼들 숨기기
  const modeButtons = document.querySelector('.listing-mode-buttons');
  if (modeButtons) {
    modeButtons.classList.add('hidden');
  }
  
  // 버튼 상태 초기화 (매물리스트가 기본 선택)
  const propertyBtn = document.getElementById("propertyListBtn");
  const briefingBtn = document.getElementById("briefingListBtn");
  
  if (propertyBtn) {
    propertyBtn.classList.add("active");
    propertyBtn.setAttribute("data-mode", "property");
  }
  if (briefingBtn) {
    briefingBtn.classList.remove("active");
    briefingBtn.removeAttribute("data-mode");
  }
  
  // 고객 정보 숨기고 고객 목록 표시
  const selectedCustomerInfo = document.getElementById("selectedCustomerInfo");
  const customerListContainer = document.getElementById("customerListContainer");
  
  if (selectedCustomerInfo) selectedCustomerInfo.classList.add("hidden");
  if (customerListContainer) customerListContainer.classList.remove("hidden");
  
  // 고객 필터 해제
  clearCustomerFilter();
  
  // 브리핑 필터 적용
  applyBriefingFilters();
}

function showCustomerDetail(c) {
  // 2차 사이드바에 고객 상세정보 표시
  const detailTitleEl = document.getElementById('secondaryPanelTitle');
  
  if (detailTitleEl) {
    detailTitleEl.textContent = '고객 상세정보';
  }
  
  // 현재 선택된 고객 저장
  window.selectedCustomer = c;
  
  // 브리핑 상태 로드
  loadBriefingStates(c.id);
  
  // 현재 고객 ID 저장
  UI_STATE.currentCustomerId = c.id;
  
  // 고객 상세정보 화면 표시
  showSecondaryPanel('viewCustomerDetail');
  
  // 고객 상세정보 렌더링
  renderCustomerDetail(c);
};

// 고객 상세정보 렌더링 함수
function renderCustomerDetail(c) {
  console.log('renderCustomerDetail 호출됨:', c);
  
  const customerDetailContent = document.getElementById('customerDetailContent');
  
  console.log('customerDetailContent 요소:', customerDetailContent);
  
  if (!customerDetailContent) {
    console.error('고객 상세정보 컨테이너를 찾을 수 없습니다.');
    return;
  }
  
  console.log('HTML 렌더링 시작');
  customerDetailContent.innerHTML = `
    <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 8px; margin-bottom: 8px;">
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">담당자</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.manager || '담당자 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">고객명</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.name || '이름 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">연락처</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.phone || '연락처 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망지역</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.regions || '희망지역 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망층수</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.floor || '희망층수 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망면적</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.area || '희망면적 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망보증금</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.deposit || '희망보증금 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망월세</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.rent || '희망월세 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">희망권리금</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.premium || '희망권리금 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">참고사항</label>
        <div style="padding: 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333; min-height: 60px; white-space: pre-wrap; line-height: 1.4;">${escapeHtml(c.notes || '참고사항 없음')}</div>
      </div>
      
      <div class="detail-row" style="margin-bottom: 6px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 2px; font-size: 12px;">상태</label>
        <div style="padding: 4px 6px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; color: #333;">${escapeHtml(c.status || '생')}</div>
      </div>
    </div>
    
    <div class="detail-actions" style="display: flex; justify-content: space-between; gap: 8px; margin-top: 8px;">
      <div style="display: flex; gap: 4px;">
        <button id="selectCustomerBtn" class="btn" style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">선택</button>
        <button id="backToListBtn" class="btn" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">이전화면</button>
      </div>
      <div style="display: flex; gap: 4px;">
        <button id="editCustomerDetailBtn" class="btn" style="padding: 8px 12px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">수정</button>
        <button id="deleteCustomerDetailBtn" class="btn" style="padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">삭제</button>
      </div>
    </div>
  `;
  
  console.log('HTML 렌더링 완료');
  
  // 버튼 이벤트 리스너 추가
  const selectBtn = document.getElementById('selectCustomerBtn');
  const backBtn = document.getElementById('backToListBtn');
  const editBtn = document.getElementById('editCustomerDetailBtn');
  const deleteBtn = document.getElementById('deleteCustomerDetailBtn');
  
  if (selectBtn) selectBtn.addEventListener('click', () => {
    // 1차사이드바에 고객정보 입력
    console.log('선택 버튼 클릭:', c);
    
    // 1차사이드바에 고객정보 표시
    const selectedCustomerInfo = document.getElementById("selectedCustomerInfo");
    const customerInfoContent = document.getElementById("customerInfoContent");
    const customerListContainer = document.getElementById("customerListContainer");
    
    if (selectedCustomerInfo && customerInfoContent) {
      // 고객 목록 숨기고 고객 정보 표시
      if (customerListContainer) customerListContainer.classList.add("hidden");
      selectedCustomerInfo.classList.remove("hidden");
      
      // 현재 선택된 고객 저장
      window.selectedCustomer = c;
      
      // 고객정보 내용 렌더링
      customerInfoContent.innerHTML = `
        <div style="background: white; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px;">
            <div style="font-weight: bold; color: #333; font-size: 14px;">${escapeHtml(c.name || '이름 없음')}</div>
            <div style="color: #666; font-size: 11px;">👤 ${escapeHtml(c.manager || '담당자 없음')}</div>
          </div>
          <div style="color: #666; font-size: 12px; margin-bottom: 3px;">📞 ${escapeHtml(c.phone || '연락처 없음')}</div>
          <div style="color: #666; font-size: 11px; line-height: 1.2; margin-bottom: 3px;">
            ${(() => {
              const summary = [];
              if (c.regions) summary.push(`📍 ${c.regions}`);
              if (c.floor || c.floor_pref) summary.push(`🏢 ${c.floor || c.floor_pref}층`);
              if (c.area || c.area_pref) summary.push(`📐 ${c.area || c.area_pref}평`);
              if (c.deposit || c.deposit_pref) summary.push(`💰 보:${c.deposit || c.deposit_pref}`);
              if (c.rent || c.rent_pref) summary.push(`💵 월:${c.rent || c.rent_pref}`);
              if (c.premium || c.premium_pref) summary.push(`🔑 권:${c.premium || c.premium_pref}`);
              return summary.length > 0 ? summary.join(' | ') : '희망 조건 없음';
            })()}
          </div>
          ${c.notes && c.notes.trim() ? `<div style="color: #888; font-size: 10px; line-height: 1.1; font-style: italic;">📝 ${escapeHtml(c.notes.trim())}</div>` : ''}
        </div>
        
        <div class="detail-actions" style="display: flex; gap: 4px; margin-bottom: 12px;">
          <button id="applyCustomerFilterBtn" class="btn" style="flex: 1; padding: 4px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">선택</button>
          <button id="editCustomerBtn" class="btn" style="flex: 1; padding: 4px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">수정</button>
          <button id="deleteCustomerBtn" class="btn" style="flex: 1; padding: 4px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">삭제</button>
          <button id="clearCustomerSelectionBtn" class="btn" style="flex: 1; padding: 4px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">초기화</button>
        </div>
      `;
      
      // 버튼 이벤트 리스너 추가
      const applyFilterBtn = document.getElementById('applyCustomerFilterBtn');
      const editBtn = document.getElementById('editCustomerBtn');
      const deleteBtn = document.getElementById('deleteCustomerBtn');
      const clearBtn = document.getElementById('clearCustomerSelectionBtn');
      
      if (applyFilterBtn) applyFilterBtn.addEventListener('click', () => applyCustomerFilter(c));
      if (editBtn) editBtn.addEventListener('click', () => window.editCustomerById(c.id));
      if (deleteBtn) deleteBtn.addEventListener('click', () => {
        if (confirm('정말로 이 고객을 삭제하시겠습니까?')) {
          window.deleteCustomerById(c.id);
        }
      });
      if (clearBtn) clearBtn.addEventListener('click', clearCustomerSelection);
    }
    
    // 2차사이드바 닫기
    const secondaryPanel = document.getElementById('secondaryPanel');
    if (secondaryPanel) {
      secondaryPanel.classList.add('hidden');
      secondaryPanel.classList.remove('visible');
    }
  });
  
  if (backBtn) backBtn.addEventListener('click', () => {
    // 고객목록으로 돌아가기
    showSecondaryPanel('viewCustomerList');
    const detailTitleEl = document.getElementById('secondaryPanelTitle');
    if (detailTitleEl) detailTitleEl.textContent = currentUser === 'admin' ? '고객 목록' : '내 고객 목록';
  });
  
  if (editBtn) editBtn.addEventListener('click', () => {
    // 수정 화면으로 이동
    console.log('수정 버튼 클릭:', c);
    
    // 현재 선택된 고객 저장 (취소 버튼용)
    window.selectedCustomer = c;
    
    // 수정 전용 패널 열기
    showSecondaryPanel('viewCustomerEdit');
    renderCustomerEditForm(c);
    
    // 제목 변경
    const detailTitleEl = document.getElementById("secondaryPanelTitle");
    if (detailTitleEl) {
      detailTitleEl.textContent = "고객 정보 수정";
    }
  });
  
  if (deleteBtn) deleteBtn.addEventListener('click', () => {
    // 삭제 확인 후 실행
    if (confirm('정말로 이 고객을 삭제하시겠습니까?')) {
      window.deleteCustomerById(c.id).then(() => {
        // 삭제 완료 후 상세정보창 닫고 고객목록으로 돌아가기
        showSecondaryPanel('viewCustomerList');
        const detailTitleEl = document.getElementById('secondaryPanelTitle');
        if (detailTitleEl) detailTitleEl.textContent = currentUser === 'admin' ? '고객 목록' : '내 고객 목록';
      });
    }
  });
}

function renderCustomerForm(c = {}) {
  showSecondaryPanel('viewCustomerForm');

  const detailTitleEl = document.getElementById("secondaryPanelTitle");
  const viewCustomerForm = document.getElementById("viewCustomerForm");
  
  if (!detailTitleEl || !viewCustomerForm) return;

  detailTitleEl.textContent = c.id ? "고객 정보 수정" : "고객 신규등록";

  viewCustomerForm.innerHTML = `
    <div style="background: #f8f9fa; padding: 8px; border-radius: 8px; margin-bottom: 10px;">
      <div style="font-size: 14px; font-weight: bold; color: #333;">${c.id ? '고객 정보 수정' : '새 고객 등록'}</div>
      <div style="color: #666; font-size: 12px; margin-top: 2px;">고객 정보를 입력해주세요</div>
    </div>
    
    <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 8px;">
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">담당자 *</label>
        <input class="form-control" id="frmManager" 
               value="${escapeHtml(c.manager || '')}" 
               placeholder="담당자명을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">고객명 *</label>
        <input class="form-control" id="frmName" 
               value="${escapeHtml(c.name || '')}"
               placeholder="고객명을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">연락처 *</label>
        <input class="form-control" id="frmPhone" 
               value="${escapeHtml(c.phone || '')}" 
               placeholder="연락처를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망지역</label>
        <input class="form-control" id="frmRegions" 
               value="${escapeHtml(c.regions || '')}" 
               placeholder="희망지역을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망층수</label>
        <input class="form-control" id="frmFloor" 
               value="${escapeHtml(c.floor_pref || '')}" 
               placeholder="희망층수를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망면적</label>
        <input class="form-control" id="frmArea" 
               value="${escapeHtml(c.area_pref || '')}" 
               placeholder="예: 20 (20평 이상) 또는 10-20 (10~20평 범위)"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망보증금</label>
        <input class="form-control" id="frmDeposit" 
               value="${escapeHtml(c.deposit_pref || '')}"
               placeholder="희망보증금을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망월세</label>
        <input class="form-control" id="frmRent" 
               value="${escapeHtml(c.rent_pref || '')}"
               placeholder="희망월세를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망권리금</label>
        <input class="form-control" id="frmPremium" 
               value="${escapeHtml(c.premium_pref || '')}"
               placeholder="희망권리금을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">참고사항</label>
        <textarea class="form-control" id="frmNotes"
                  rows="4" placeholder="참고사항을 입력하세요"
                  style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; resize: vertical; max-height: 120px; overflow-y: auto; margin-left: -8px;">${escapeHtml(c.notes || '')}</textarea>
      </div>
    </div>
    
    <div class="detail-actions" style="margin-top: 6px; display: flex; gap: 6px;">
      <button id="saveCustomerBtn" class="btn" style="flex: 1; padding: 6px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px;">저장</button>
      <button id="cancelCustomerBtn" class="btn" style="flex: 1; padding: 6px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">취소</button>
    </div>
  `;

  const saveBtn = document.getElementById('saveCustomerBtn');
  const cancelBtn = document.getElementById('cancelCustomerBtn');
  
  if (saveBtn) saveBtn.addEventListener('click', () => submitCustomerForm(c.id || 'new'));
  if (cancelBtn) cancelBtn.addEventListener('click', () => {
    console.log('신규등록 취소 버튼 클릭됨');
    console.log('window.selectedCustomer:', window.selectedCustomer);
    
    // 고객상세정보로 돌아가기
    if (window.selectedCustomer) {
      console.log('고객상세정보로 돌아가기');
      renderCustomerDetail(window.selectedCustomer);
    } else {
      console.log('고객목록으로 돌아가기');
      // 선택된 고객이 없으면 고객목록으로 돌아가기
      showSecondaryPanel('viewCustomerList');
      const detailTitleEl = document.getElementById('secondaryPanelTitle');
      if (detailTitleEl) detailTitleEl.textContent = currentUser === 'admin' ? '고객 목록' : '내 고객 목록';
    }
  });
}
// 고객 수정 전용 폼 렌더링 함수
function renderCustomerEditForm(c = {}) {
  const viewCustomerEdit = document.getElementById("viewCustomerEdit");
  
  if (!viewCustomerEdit) return;

  viewCustomerEdit.innerHTML = `
    <div style="background: #fff3cd; padding: 8px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #ffeaa7;">
      <div style="font-size: 14px; font-weight: bold; color: #856404;">고객 정보 수정</div>
      <div style="color: #856404; font-size: 12px; margin-top: 2px;">기존 고객 정보를 수정합니다</div>
    </div>
    
    <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 8px;">
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">담당자 *</label>
        <input class="form-control" id="editManager" 
               value="${escapeHtml(cleanValue(c.manager))}" 
               placeholder="담당자명을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">고객명 *</label>
        <input class="form-control" id="editName" 
               value="${escapeHtml(cleanValue(c.name))}"
               placeholder="고객명을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">연락처 *</label>
        <input class="form-control" id="editPhone" 
               value="${escapeHtml(cleanValue(c.phone))}" 
               placeholder="연락처를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망지역</label>
        <input class="form-control" id="editRegions" 
               value="${escapeHtml(cleanValue(c.regions))}" 
               placeholder="희망지역을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망층수</label>
        <input class="form-control" id="editFloor" 
               value="${escapeHtml(cleanValue(c.floor))}" 
               placeholder="희망층수를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망면적</label>
        <input class="form-control" id="editArea" 
               value="${escapeHtml(cleanValue(c.area))}" 
               placeholder="예: 20 (20평 이상) 또는 10-20 (10~20평 범위)"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망보증금</label>
        <input class="form-control" id="editDeposit" 
               value="${escapeHtml(cleanValue(c.deposit))}"
               placeholder="희망보증금을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망월세</label>
        <input class="form-control" id="editRent" 
               value="${escapeHtml(cleanValue(c.rent))}"
               placeholder="희망월세를 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">희망권리금</label>
        <input class="form-control" id="editPremium" 
               value="${escapeHtml(cleanValue(c.premium))}"
               placeholder="희망권리금을 입력하세요"
               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-left: -8px;">
      </div>
      
      <div class="detail-row" style="margin-bottom: 8px;">
        <label style="display: block; font-weight: 600; color: #333; margin-bottom: 3px; font-size: 12px;">참고사항</label>
        <textarea class="form-control" id="editNotes"
                  rows="4" placeholder="참고사항을 입력하세요"
                  style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; resize: vertical; max-height: 120px; overflow-y: auto; margin-left: -8px;">${escapeHtml(cleanValue(c.notes))}</textarea>
      </div>
    </div>
    
    <div class="detail-actions" style="margin-top: 6px; display: flex; gap: 6px;">
      <button id="updateCustomerBtn" class="btn" style="flex: 1; padding: 6px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px;">수정</button>
      <button id="cancelEditBtn" class="btn" style="flex: 1; padding: 6px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">취소</button>
    </div>
  `;

  const updateBtn = document.getElementById('updateCustomerBtn');
  const cancelBtn = document.getElementById('cancelEditBtn');
  
  if (updateBtn) updateBtn.addEventListener('click', () => submitCustomerEditForm(c.id));
  if (cancelBtn) cancelBtn.addEventListener('click', () => {
    console.log('수정 취소 버튼 클릭됨');
    console.log('window.selectedCustomer:', window.selectedCustomer);
    
    // 고객상세정보로 돌아가기
    if (window.selectedCustomer) {
      console.log('고객상세정보로 돌아가기');
      showSecondaryPanel('viewCustomerDetail');
      renderCustomerDetail(window.selectedCustomer);
    } else {
      console.log('고객목록으로 돌아가기');
      // 선택된 고객이 없으면 고객목록으로 돌아가기
      showSecondaryPanel('viewCustomerList');
      const detailTitleEl = document.getElementById('secondaryPanelTitle');
      if (detailTitleEl) detailTitleEl.textContent = currentUser === 'admin' ? '고객 목록' : '내 고객 목록';
    }
  });
}

window.changeCustomerStatusById = async function(customerId) {
  console.log('🔄 changeCustomerStatus 호출:', customerId);
  
  // 현재 고객 정보 가져오기
  const customer = getCustomerById(customerId);
  if (!customer) {
    console.error('고객을 찾을 수 없습니다:', customerId);
    return;
  }
  
  // 상태 변경 옵션 (나중에 확장 가능)
  const statusOptions = [
    { value: 'active', label: '활성', color: '#28a745' },
    { value: 'inactive', label: '비활성', color: '#6c757d' },
    { value: 'pending', label: '대기중', color: '#ffc107' },
    { value: 'completed', label: '완료', color: '#17a2b8' }
  ];
  
  // 현재 상태 확인 (기본값: active)
  const currentStatus = customer.status || 'active';
  
  // 상태 선택 다이얼로그
  const selectedStatus = prompt(
    `고객 상태를 변경하세요:\n\n` +
    `${statusOptions.map(opt => `${opt.value}: ${opt.label}`).join('\n')}\n\n` +
    `현재 상태: ${currentStatus}\n` +
    `새로운 상태를 입력하세요:`,
    currentStatus
  );
  
  if (!selectedStatus || selectedStatus === currentStatus) {
    return;
  }
  
  // 유효한 상태인지 확인
  const validStatus = statusOptions.find(opt => opt.value === selectedStatus);
  if (!validStatus) {
    alert('유효하지 않은 상태입니다.');
    return;
  }
  
  try {
    const url = `/api/customers/${customerId}`;
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'X-User': currentUser
      },
      body: JSON.stringify({
        status: selectedStatus
      })
    });
    
    if (response.ok) {
      alert(`고객 상태가 '${validStatus.label}'로 변경되었습니다.`);
      // 고객 목록 새로고침
      loadCustomerList(currentUser === 'admin' ? 'all' : 'own');
    } else {
      const error = await response.text();
      console.error('상태 변경 실패:', error);
      alert(`상태 변경 실패: ${error}`);
    }
  } catch (error) {
    console.error('상태 변경 중 오류:', error);
    // 상태 변경 중 오류가 발생했습니다.
  }
}

// 고객의 저장된 필터데이터로 매물 필터링 적용
function applyCustomerFilter(customer) {
  console.log('applyCustomerFilter 호출:', customer);
  
  // 현재 선택된 고객 저장
  window.selectedCustomer = customer;
  
  // 브리핑 상태 로드
  loadBriefingStates(customer.id);
  
  // 매물리스트 타이틀을 버튼으로 변경
  const listingTitle = document.querySelector(".listing-title");
  if (listingTitle) {
    listingTitle.style.cursor = "pointer";
    listingTitle.style.color = "#007bff";
    listingTitle.style.textDecoration = "underline";
    listingTitle.onclick = () => {
      UI_STATE.isBriefingListMode = false;
      applyAllFilters();
    };
  }
  
  // 고객 선택 시 버튼들 표시
  const modeButtons = document.querySelector('.listing-mode-buttons');
  if (modeButtons) {
    modeButtons.classList.remove('hidden');
    console.log('버튼들 표시됨:', modeButtons.className);
  } else {
    console.log('버튼 요소를 찾을 수 없음');
  }
  
  // 고객 선택 시 매물리스트 모드로 기본 설정
  switchToListingMode('property');
  
  // 현재 고객 ID 저장
  UI_STATE.currentCustomerId = customer.id;
  
  try {
    // 지역명 정규화 함수 (서버의 normalize_region 함수와 동일한 로직)
    function normalizeRegion(region) {
      if (!region) return region;
      
      region = region.trim();
      
      // "구 전체", "구 전부" 패턴 처리
      if (region.includes("구 전체") || region.includes("구 전부")) {
        return region.split("구")[0] + "구";
      }
      
      // "구전체", "구전부" 패턴 처리 (공백 없는 경우)
      if (region.includes("구전체") || region.includes("구전부")) {
        return region.split("구전체")[0] + "구";
      }
      
      // "시 전체", "시 전부" 패턴 처리
      if (region.includes("시 전체") || region.includes("시 전부")) {
        return region.split("시")[0] + "시";
      }
      
      // "시전체", "시전부" 패턴 처리 (공백 없는 경우)
      if (region.includes("시전체") || region.includes("시전부")) {
        return region.split("시전체")[0] + "시";
      }
      
      return region;
    }
    
    // 고객의 저장된 필터데이터 파싱
    let filterData = {};
    if (customer.filter_data) {
      filterData = JSON.parse(customer.filter_data);
    } else {
      // 기존 방식 호환성 (filter_data가 없는 경우)
      filterData = {
        region: customer.regions || '',
        floor: customer.floor || '',
        area_real: customer.area || '',
        deposit: customer.deposit || '',
        rent: customer.rent || '',
        premium: customer.premium || ''
      };
    }

    // CUSTOMER_FILTERS 초기화
    Object.keys(CUSTOMER_FILTERS).forEach(k => delete CUSTOMER_FILTERS[k]);
    
    // 고객 필터에만 사용할 필드들 (필요한 필드만)
    const customerFilterKeys = ['region', 'region2', 'floor', 'area_real', 'deposit', 'rent', 'premium'];
    
    // 빈 값이 아닌 필드만 필터에 추가 (지역명 정규화 포함, notes 제외)
    Object.keys(filterData).forEach(key => {
      if (customerFilterKeys.includes(key) && filterData[key] && filterData[key].toString().trim() !== '') {
        let value = filterData[key].toString().trim();
        
        // region 필드인 경우 정규화 및 다중 지역 처리
        if (key === 'region') {
          // 쉼표로 구분된 여러 지역 처리
          const regions = value.split(',').map(r => r.trim()).filter(r => r);
          const regionList = [];
          const region2List = [];
          
          regions.forEach(region => {
            const normalizedRegion = normalizeRegion(region);
            
            // 시군구 단위인지 확인 (구, 시로 끝나는 경우)
            if (normalizedRegion.includes('구') || normalizedRegion.includes('시')) {
              region2List.push(normalizedRegion);
            } else {
              regionList.push(normalizedRegion);
            }
          });
          
          // 결과 설정
          if (regionList.length > 0) {
            CUSTOMER_FILTERS['region'] = regionList.join(',');
            console.log('읍면동리 단위 지역을 region에 설정:', regionList.join(','));
          }
          if (region2List.length > 0) {
            CUSTOMER_FILTERS['region2'] = region2List.join(',');
            console.log('시군구 단위 지역을 region2에 설정:', region2List.join(','));
          }
        } else {
          // floor 필드 특별 처리 (지역명이 잘못 들어간 경우 처리)
          if (key === 'floor') {
            // 지역명 패턴인지 확인 (구, 시로 끝나는 경우)
            if (value.includes('구') || value.includes('시')) {
              // 지역명이 잘못 들어간 경우 region2로 이동
              const normalizedRegion = normalizeRegion(value);
              CUSTOMER_FILTERS['region2'] = normalizedRegion;
              console.log('floor 필드에 지역명이 들어있어 region2로 이동:', value);
            } else {
              // 숫자나 층수 정보인 경우 그대로 사용
              CUSTOMER_FILTERS[key] = value;
            }
          }
          // 면적 필드 특별 처리 (단일값은 이상 검색, 범위는 그대로)
          else if (key === 'area_real') {
            if (value.includes('-')) {
              // 범위가 지정된 경우 그대로 사용
              CUSTOMER_FILTERS[key] = value;
            } else {
              // 단일값인 경우 이상 검색으로 처리
              const numValue = parseFloat(value);
              if (!isNaN(numValue) && numValue > 0) {
                CUSTOMER_FILTERS[key] = `${numValue}-`;
              } else {
                CUSTOMER_FILTERS[key] = value;
              }
            }
          }
          // 보증금, 월세, 권리금은 범위로 처리 (0 ~ 입력값)
          else if (key === 'deposit' || key === 'rent' || key === 'premium') {
            const numValue = parseFloat(value);
            if (!isNaN(numValue) && numValue > 0) {
              CUSTOMER_FILTERS[key] = `0-${numValue}`;
            } else {
              CUSTOMER_FILTERS[key] = value;
            }
          } else {
            CUSTOMER_FILTERS[key] = value;
          }
        }
      }
    });

    // 디버깅을 위한 로그 추가
    console.log('고객 필터 적용:', {
      customerName: customer.name,
      originalFilterData: filterData,
      normalizedFilters: CUSTOMER_FILTERS
    });
    
    // 필터 적용
    applyAllFilters();
    
    // 2차 사이드바 닫기
    const secondaryPanel = document.getElementById('secondaryPanel');
    if (secondaryPanel) {
      secondaryPanel.classList.add('hidden');
      secondaryPanel.classList.remove('visible');
    }
    
    // ${customer.name} 고객의 필터가 적용되었습니다.
    
  } catch (error) {
    console.error('고객 필터 적용 중 오류:', error);
    alert('필터 적용 중 오류가 발생했습니다.');
  }
}

// 고객 필터 변경 핸들러
function handleCustomerFilterChange() {
  const select = document.getElementById('customerFilterSelect');
  if (select) {
    const filter = select.value;
    loadCustomerList(filter);
  }
}

// 고객 필터 해제
function clearCustomerFilter() {
  // CUSTOMER_FILTERS 초기화
  Object.keys(CUSTOMER_FILTERS).forEach(k => delete CUSTOMER_FILTERS[k]);
  
  // 필터 적용
  applyAllFilters();
  
      // 고객 필터가 해제되었습니다.
}

// 전역 함수로 등록
window.handleCustomerFilterChange = handleCustomerFilterChange;

function applyCustomerFormAsFilter() {
  // 고객 폼의 입력값을 필터로 적용
  const formData = {
    region: document.getElementById('frmRegions')?.value || '',
    floor: document.getElementById('frmFloor')?.value || '',
    area_real: document.getElementById('frmArea')?.value || '',
    deposit: document.getElementById('frmDeposit')?.value || '',
    rent: document.getElementById('frmRent')?.value || '',
    premium: document.getElementById('frmPremium')?.value || ''
  };

  // CUSTOMER_FILTERS 초기화
  Object.keys(CUSTOMER_FILTERS).forEach(k => delete CUSTOMER_FILTERS[k]);
  
  // 빈 값이 아닌 필드만 필터에 추가 (notes 제외)
  Object.keys(formData).forEach(key => {
    if (key !== 'notes' && formData[key] && formData[key].trim() !== '') {
      CUSTOMER_FILTERS[key] = formData[key].trim();
    }
  });

  // 필터 적용
  applyAllFilters();
  
  // 2차 사이드바 닫기
  const secondaryPanel = document.getElementById('secondaryPanel');
  if (secondaryPanel) {
    secondaryPanel.classList.add('hidden');
    secondaryPanel.classList.remove('visible');
  }
  
      // 고객 정보가 필터로 적용되었습니다.
}
async function submitCustomerForm(customerId) {
  console.log('고객 폼 제출:', customerId);

  if (!currentUser) {
    alert('로그인이 필요합니다.');
    return;
  }

  // 수정 모드인지 확인
  const isEditMode = customerId && customerId !== 'new';

  // 폼 데이터 수집
  const areaVal = document.getElementById('frmArea')?.value || '';
  const depositVal = document.getElementById('frmDeposit')?.value || '';
  const rentVal = document.getElementById('frmRent')?.value || '';
  const premiumVal = document.getElementById('frmPremium')?.value || '';

  // 상단필터 방식으로 필터데이터 구성 (지역명 정규화 포함)
  const regionsInput = document.getElementById('frmRegions')?.value || '';
  
  // 지역명 정규화 함수 (서버의 normalize_region 함수와 동일한 로직)
  function normalizeRegion(region) {
    if (!region) return region;
    
    region = region.trim();
    
    // "구 전체", "구 전부" 패턴 처리
    if (region.includes("구 전체") || region.includes("구 전부")) {
      return region.split("구")[0] + "구";
    }
    
    // "구전체", "구전부" 패턴 처리 (공백 없는 경우)
    if (region.includes("구전체") || region.includes("구전부")) {
      return region.split("구전체")[0] + "구";
    }
    
    // "시 전체", "시 전부" 패턴 처리
    if (region.includes("시 전체") || region.includes("시 전부")) {
      return region.split("시")[0] + "시";
    }
    
    // "시전체", "시전부" 패턴 처리 (공백 없는 경우)
    if (region.includes("시전체") || region.includes("시전부")) {
      return region.split("시전체")[0] + "시";
    }
    
    return region;
  }
  
  const normalizedRegion = normalizeRegion(regionsInput);
  
  // 필터 데이터 구성 (notes 제외)
  const filterData = {
    region: normalizedRegion,  // 정규화된 지역명 사용
    floor: document.getElementById('frmFloor')?.value || '',
    area_real: areaVal,
    deposit: depositVal,
    rent: rentVal,
    premium: premiumVal
  };

  const formData = {
    manager: document.getElementById('frmManager')?.value || '',
    name: document.getElementById('frmName')?.value || '',
    phone: document.getElementById('frmPhone')?.value || '',
    regions: document.getElementById('frmRegions')?.value || '',
    floor: document.getElementById('frmFloor')?.value || '',
    area: areaVal,
    deposit: depositVal,
    rent: rentVal,
    premium: premiumVal,
    notes: document.getElementById('frmNotes')?.value || '',
    // 상단필터 방식의 필터데이터 저장
    filter_data: JSON.stringify(filterData),
    created_by: currentUser,
    created_at: new Date().toISOString()
  };

  // 필수 필드 검증
  if (!formData.name.trim()) {
    alert('고객명을 입력해주세요.');
    return;
  }
  if (!formData.phone.trim()) {
    alert('연락처를 입력해주세요.');
    return;
  }

  try {
    const url = isEditMode ? `/api/customers/${customerId}` : '/api/customers/';
    const method = isEditMode ? 'PUT' : 'POST';
    
    // formData에서 NaN 값 제거
    const cleanedFormData = cleanObject(formData);
    console.log('🧹 정리된 formData (submitCustomerForm):', cleanedFormData);
    
    const response = await fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'X-User': currentUser
      },
      body: JSON.stringify(cleanedFormData)
    });
    if (response.ok) {
      const result = await response.json();
      console.log('고객 저장 성공:', result);
      alert(isEditMode ? '고객정보가 수정되었습니다.' : '고객정보가 저장되었습니다.');
      const secondaryPanel = document.getElementById('secondaryPanel');
      if (secondaryPanel) {
        secondaryPanel.classList.add('hidden');
        secondaryPanel.classList.remove('visible');
      }
      if (currentUser === 'admin') {
        loadCustomerList('all');
      } else {
        loadCustomerList('own');
      }
      
      // 고객 저장 후 목록 갱신
      if (window.afterCustomerSaved) {
        window.afterCustomerSaved();
      }
    } else {
      const error = await response.text();
      console.error('고객 저장 실패:', error);
      alert('저장에 실패했습니다: ' + error);
    }
  } catch (error) {
    console.error('고객 저장 중 오류:', error);
    alert('저장 중 오류가 발생했습니다.');
  }
}

// 고객 수정 전용 폼 제출 함수
async function submitCustomerEditForm(customerId) {
  console.log('고객 수정 폼 제출:', customerId);

  if (!currentUser) {
    alert('로그인이 필요합니다.');
    return;
  }

  // 폼 데이터 수집 (NaN 값 처리)
  const areaVal = cleanValue(document.getElementById('editArea')?.value) || '';
  const depositVal = cleanValue(document.getElementById('editDeposit')?.value) || '';
  const rentVal = cleanValue(document.getElementById('editRent')?.value) || '';
  const premiumVal = cleanValue(document.getElementById('editPremium')?.value) || '';

  // 상단필터 방식으로 필터데이터 구성 (지역명 정규화 포함)
  const regionsInput = cleanValue(document.getElementById('editRegions')?.value) || '';
  
  // 지역명 정규화 함수 (서버의 normalize_region 함수와 동일한 로직)
  function normalizeRegion(region) {
    if (!region) return region;
    
    region = region.trim();
    
    // "구 전체", "구 전부" 패턴 처리
    if (region.includes("구 전체") || region.includes("구 전부")) {
      return region.split("구")[0] + "구";
    }
    
    // "구전체", "구전부" 패턴 처리 (공백 없는 경우)
    if (region.includes("구전체") || region.includes("구전부")) {
      return region.split("구전체")[0] + "구";
    }
    
    // "시 전체", "시 전부" 패턴 처리
    if (region.includes("시 전체") || region.includes("시 전부")) {
      return region.split("시")[0] + "시";
    }
    
    // "시전체", "시전부" 패턴 처리 (공백 없는 경우)
    if (region.includes("시전체") || region.includes("시전부")) {
      return region.split("시전체")[0] + "시";
    }
    
    return region;
  }
  
  const normalizedRegion = normalizeRegion(regionsInput);
  
  // 필터 데이터 구성 (notes 제외)
  const filterData = {
    region: normalizedRegion,  // 정규화된 지역명 사용
    floor: cleanValue(document.getElementById('editFloor')?.value) || '',
    area_real: areaVal,
    deposit: depositVal,
    rent: rentVal,
    premium: premiumVal
  };

  const formData = {
    manager: cleanValue(document.getElementById('editManager')?.value) || '',
    name: cleanValue(document.getElementById('editName')?.value) || '',
    phone: cleanValue(document.getElementById('editPhone')?.value) || '',
    regions: cleanValue(document.getElementById('editRegions')?.value) || '',
    floor: cleanValue(document.getElementById('editFloor')?.value) || '',
    area: areaVal,
    deposit: depositVal,
    rent: rentVal,
    premium: premiumVal,
    notes: cleanValue(document.getElementById('editNotes')?.value) || '',
    // 상단필터 방식의 필터데이터 저장
    filter_data: JSON.stringify(filterData)
  };

  // 필수 필드 검증
  if (!formData.name.trim()) {
    alert('고객명을 입력해주세요.');
    return;
  }
  if (!formData.phone.trim()) {
    alert('연락처를 입력해주세요.');
    return;
  }

  try {
    const url = `/api/customers/${customerId}`;
    
    // formData에서 NaN 값 제거
    const cleanedFormData = cleanObject(formData);
    console.log('🧹 정리된 formData:', cleanedFormData);
    
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'X-User': currentUser
      },
      body: JSON.stringify(cleanedFormData)
    });
    
    if (response.ok) {
      try {
        const result = await response.json();
        console.log('고객 수정 성공:', result);
        // 고객정보가 수정되었습니다.
      } catch (jsonError) {
        console.log('JSON 파싱 실패, 하지만 수정은 성공:', jsonError);
        // 고객정보가 수정되었습니다.
      }
      
      // 패널 닫기
      const secondaryPanel = document.getElementById('secondaryPanel');
      if (secondaryPanel) {
        secondaryPanel.classList.add('hidden');
        secondaryPanel.classList.remove('visible');
      }
      
      // 고객 목록 새로고침
      if (currentUser === 'admin') {
        loadCustomerList('all');
      } else {
        loadCustomerList('own');
      }
      
      // 고객 저장 후 목록 갱신
      if (window.afterCustomerSaved) {
        window.afterCustomerSaved();
      }
    } else {
      const error = await response.text();
      console.error('고객 수정 실패:', error);
      // 수정에 실패했습니다: ' + error
    }
  } catch (error) {
    console.error('고객 수정 중 오류:', error);
    console.error('오류 타입:', typeof error);
    console.error('오류 메시지:', error.message);
    console.error('오류 스택:', error.stack);
    
    // 더 구체적인 오류 메시지 제공
    let errorMessage = '수정 중 오류가 발생했습니다.';
    if (error.message) {
      errorMessage += ` (${error.message})`;
    }
    // errorMessage
  }
}

// 전역 함수로 노출
window.initMap = initMap;
// window.editCustomer = editCustomer; // 이미 window.editCustomerById로 정의됨
// window.deleteCustomer = deleteCustomer; // 이미 window.deleteCustomerById로 정의됨

// 고객 상태 변경 함수
window.changeCustomerStatus = async function(customerId, newStatus) {
  console.log('🔄 고객 상태 변경:', customerId, '->', newStatus);
  
  try {
    const url = `/api/customers/${customerId}`;
    const response = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'X-User': currentUser
      },
      body: JSON.stringify({ status: newStatus })
    });
    
    if (response.ok) {
      console.log('✅ 고객 상태 변경 성공');
      // 고객 목록 새로고침
      loadCustomerList(currentUser === 'admin' ? 'all' : 'own');
    } else {
      const error = await response.text();
      console.error('❌ 고객 상태 변경 실패:', error);
      // 상태 변경에 실패했습니다: ' + error
    }
  } catch (error) {
    console.error('❌ 고객 상태 변경 중 오류:', error);
    alert('상태 변경 중 오류가 발생했습니다.');
  }
};

// 고객 상태 드롭다운 표시 함수
window.showStatusDropdown = function(event, customerId, currentStatus) {
  event.stopPropagation();
  
  // 기존 드롭다운 제거
  const existingDropdown = document.querySelector('.status-dropdown');
  if (existingDropdown) {
    existingDropdown.remove();
  }
  
  const statusOptions = [
    { value: '생', label: '생성', color: '#28a745', bgColor: '#d4edda' },
    { value: '완', label: '완료', color: '#0c5460', bgColor: '#d1ecf1' },
    { value: '보류', label: '보류', color: '#856404', bgColor: '#fff3cd' },
    { value: '포기', label: '포기', color: '#721c24', bgColor: '#f8d7da' }
  ];
  
  const dropdown = document.createElement('div');
  dropdown.className = 'status-dropdown';
  dropdown.style.cssText = `
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    z-index: 1000;
    min-width: 80px;
  `;
  
  statusOptions.forEach(option => {
    const item = document.createElement('div');
    item.style.cssText = `
      padding: 6px 10px;
      cursor: pointer;
      font-size: 11px;
      border-bottom: 1px solid #f0f0f0;
      background: ${option.value === currentStatus ? '#f8f9fa' : 'white'};
    `;
    item.textContent = option.label;
    
    item.addEventListener('click', (e) => {
      e.stopPropagation(); // 이벤트 버블링 방지
      window.changeCustomerStatus(customerId, option.value);
      dropdown.remove();
    });
    
    item.addEventListener('mouseenter', () => {
      item.style.backgroundColor = '#f8f9fa';
    });
    
    item.addEventListener('mouseleave', () => {
      item.style.backgroundColor = option.value === currentStatus ? '#f8f9fa' : 'white';
    });
    
    dropdown.appendChild(item);
  });
  
  // 드롭다운을 클릭한 요소에 추가
  event.target.parentNode.style.position = 'relative';
  event.target.parentNode.appendChild(dropdown);
  
  // 외부 클릭 시 드롭다운 닫기
  setTimeout(() => {
    document.addEventListener('click', function closeDropdown() {
      dropdown.remove();
      document.removeEventListener('click', closeDropdown);
    });
  }, 100);
};

// 고객 상태 필터 변경 핸들러
window.handleStatusFilterChange = function() {
  const statusFilter = document.getElementById('customerStatusFilter');
  if (statusFilter) {
    const selectedStatus = statusFilter.value;
    console.log('🔄 상태 필터 변경:', selectedStatus);
    
    // 현재 고객 목록에서 필터링
    if (window.currentCustomerList) {
      let filteredList = window.currentCustomerList;
      
      if (selectedStatus !== 'all') {
        filteredList = window.currentCustomerList.filter(customer => 
          (customer.status || '생') === selectedStatus
        );
      }
      
      // 필터링된 목록만 렌더링 (필터는 유지)
      renderFilteredCustomerList(filteredList);
    }
  }
};

// 고객 필터 변경 핸들러
window.handleCustomerFilterChange = function() {
  const filterSelect = document.getElementById('customerFilterSelect');
  if (filterSelect) {
    const selectedFilter = filterSelect.value;
    loadCustomerList(selectedFilter);
  }
}; 
/**************************************
 * ===== DOMContentLoaded 초기화 =====
 **************************************/
window.addEventListener("DOMContentLoaded", async () => {
  // 모듈화된 초기화 함수 호출
  if (window.initializeApp) {
    await window.initializeApp();
  } else {
    console.error('initializeApp 함수를 찾을 수 없습니다.');
  }
});

// 클러스터 클릭 위임 바인딩은 메인 DOMContentLoaded에서 처리됨 

// 클러스터 클릭 위임 바인딩은 메인 DOMContentLoaded에서 처리됨

// 토스트 알림 함수
function showToast(message, type = 'info') {
  // 기존 토스트 제거
  const existingToast = document.querySelector('.toast-notification');
  if (existingToast) {
    existingToast.remove();
  }
  
  // 토스트 컨테이너 생성
  const toast = document.createElement('div');
  toast.className = 'toast-notification';
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
    color: white;
    padding: 12px 20px;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 10000;
    font-size: 14px;
    max-width: 300px;
    word-wrap: break-word;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
  `;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  // 애니메이션으로 나타나기
  setTimeout(() => {
    toast.style.opacity = '1';
    toast.style.transform = 'translateX(0)';
  }, 100);
  
  // 3초 후 자동으로 사라지기
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateX(100%)';
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
    }, 300);
  }, 3000);
}

/**************************************
 * ===== 지도 컨트롤 기능 =====
 **************************************/

// MarkerClustering.js 동적 로드
function loadMarkerClustering() {
  if (typeof MarkerClustering !== 'undefined') {
    console.log('✅ MarkerClustering이 이미 로드되어 있습니다.');
    return;
  }
  
  const script = document.createElement('script');
  script.src = '/static/js/vendor/MarkerClustering.js';
  script.onload = function() {
    console.log('✅ MarkerClustering이 성공적으로 로드되었습니다.');
  };
  script.onerror = function() {
    console.error('❌ MarkerClustering 로드에 실패했습니다.');
  };
  document.head.appendChild(script);
}

// Streetview 모듈은 이제 HTML에서 직접 로드됩니다

// 지도 컨트롤 초기화
function initMapControls() {
  // 로드뷰 버튼
  const roadviewBtn = document.getElementById('roadviewBtn');
  if (roadviewBtn) {
    roadviewBtn.addEventListener('click', toggleRoadview);
  }
  
  // 지적편집도 버튼
  const cadastralBtn = document.getElementById('cadastralBtn');
  if (cadastralBtn) {
    cadastralBtn.addEventListener('click', toggleCadastralMap);
  }
  
  // 거리제기 버튼
  const distanceBtn = document.getElementById('distanceBtn');
  if (distanceBtn) {
    distanceBtn.addEventListener('click', toggleDistanceMeasure);
  }
  
  // 로드뷰 닫기 버튼
  const roadviewCloseBtn = document.getElementById('roadviewCloseBtn');
  if (roadviewCloseBtn) {
    roadviewCloseBtn.addEventListener('click', function() {
      console.log('🔄 로드뷰 닫기 버튼 클릭됨');
      closePanorama();
    });
  } else {
    console.error('❌ roadviewCloseBtn을 찾을 수 없습니다.');
  }
  
  // 거리제기 핸들러는 이미 initMap에서 추가됨
  
  // ESC 키로 거리제기 모드 해제
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && IS_DISTANCE_MODE) {
      toggleDistanceMeasure();
    }
  });
  

}

// 로드뷰 토글
function toggleRoadview() {
  console.log('🛣️ 로드뷰 토글 버튼 클릭됨');
  const container = document.getElementById('roadviewContainer');
  if (!container) {
    console.error('❌ roadviewContainer를 찾을 수 없습니다.');
    return;
  }
  
  if (container.classList.contains('hidden')) {
    console.log('🔄 로드뷰 열기 시도...');
    openRoadview();
  } else {
    console.log('🔄 로드뷰 닫기 시도...');
    closeRoadview();
  }
}

// 거리뷰 레이어 토글
function openRoadview() {
  console.log('🔄 거리뷰 레이어 토글 시작');
  
  // 거리뷰 레이어가 이미 표시되어 있는지 확인
  if (MAP._streetLayer) {
    // 레이어 제거
    console.log('🔄 거리뷰 레이어 제거 중...');
    MAP._streetLayer.setMap(null);
    MAP._streetLayer = null;
    showToast('거리뷰 레이어가 비활성화되었습니다.', 'info');
    console.log('✅ 거리뷰 레이어 제거 완료');
    return;
  }
  
  // 거리뷰 레이어 생성 및 표시
  try {
    console.log('🔄 거리뷰 레이어 생성 중...');
    MAP._streetLayer = new naver.maps.StreetLayer();
    MAP._streetLayer.setMap(MAP);
    
    // 거리뷰 레이어 클릭 이벤트 - 가장 가까운 거리뷰 지점으로 자동 이동
    naver.maps.Event.addListener(MAP._streetLayer, 'click', function(e) {
      console.log('📍 거리뷰 레이어 클릭:', e.coord);
      console.log('📍 클릭 이벤트 전체:', e);
      
      // 클릭한 위치에서 가장 가까운 거리뷰 지점으로 자동 이동
      if (e.coord) {
        console.log('🔄 openPanorama 함수 호출 시작');
        openPanorama(e.coord);
      } else {
        console.error('❌ 클릭한 위치의 좌표가 없습니다.');
      }
    });
    
    // 지도 클릭 이벤트에서도 거리뷰 레이어 클릭 처리
    naver.maps.Event.addListener(MAP, 'click', function(e) {
      if (MAP._streetLayer) {
        console.log('📍 지도 클릭 (거리뷰 레이어 활성화됨):', e.coord);
        console.log('🔄 거리뷰 레이어 클릭 이벤트 시뮬레이션');
        
        // 거리뷰 레이어 클릭 이벤트를 직접 호출
        if (e.coord) {
          console.log('🔄 openPanorama 함수 호출 시작');
          openPanorama(e.coord);
        }
      }
    });
    
    // 거리뷰 레이어 로드 완료 이벤트
    naver.maps.Event.addListener(MAP._streetLayer, 'load', function() {
      console.log('✅ 거리뷰 레이어 로드 완료');
    });
    
    // 거리뷰 레이어 에러 이벤트
    naver.maps.Event.addListener(MAP._streetLayer, 'error', function(error) {
      console.error('❌ 거리뷰 레이어 에러:', error);
    });
    
    showToast('거리뷰 레이어가 활성화되었습니다. 지도에서 거리뷰 아이콘을 클릭하세요.', 'info');
    console.log('✅ 거리뷰 레이어 생성 완료');
    
  } catch (error) {
    console.error('❌ 거리뷰 레이어 생성 실패:', error);
    showToast('거리뷰 레이어를 생성할 수 없습니다.', 'error');
  }
}
  
// 거리뷰 레이어에서 클릭 시 파노라마 열기
function openPanorama(position) {
  console.log('🔄 openPanorama 함수 시작');
  console.log('📍 전달받은 위치:', position);
  console.log('🔍 Panorama API 확인:', typeof naver.maps.Panorama);
  
  if (typeof naver.maps.Panorama === 'undefined') {
    console.error('❌ Panorama API가 정의되지 않음');
    showToast('거리뷰 기능을 사용할 수 없습니다.', 'error');
    return;
  }
  
  const container = document.getElementById('roadviewContainer');
  const roadviewDiv = document.getElementById('roadview');
  const minimapContent = document.querySelector('.minimap-content');
  
  if (!container || !roadviewDiv || !minimapContent) {
    console.error('❌ 필요한 DOM 요소를 찾을 수 없습니다.');
    return;
  }
  
  try {
    console.log('🔄 파노라마 초기화 시작...');
    
    // 컨테이너 크기 확인
    const containerWidth = roadviewDiv.offsetWidth || window.innerWidth;
    const containerHeight = roadviewDiv.offsetHeight || window.innerHeight;
    console.log('📏 컨테이너 크기:', containerWidth, 'x', containerHeight);
    
    // 파노라마를 roadview div에 생성
    ROADVIEW = new naver.maps.Panorama(roadviewDiv, {
      position: position,
      pov: {
        pan: 0,
        tilt: 0,
        fov: 90
      },
      zoom: 1,
      enableWheel: true,
      enableKeyboard: true,
      enableDoubleClick: true,
      size: new naver.maps.Size(containerWidth, containerHeight)
    });
    
    console.log('✅ Panorama 객체 생성 완료:', ROADVIEW);
    
    // 미니맵 생성
    ROADVIEW_MINIMAP = new naver.maps.Map(minimapContent, {
      center: position,
      zoom: 15,
      mapTypeControl: false,
      scaleControl: false,
      logoControl: false,
      mapDataControl: false,
      zoomControl: false,
      streetViewControl: false
    });
    
    // 미니맵이 제대로 로드되었는지 확인
    console.log('🔍 미니맵 생성 완료:', ROADVIEW_MINIMAP);
    console.log('🔍 minimapContent 크기:', minimapContent.offsetWidth, 'x', minimapContent.offsetHeight);
    
    // 미니맵이 로드되지 않을 경우를 대비해서 즉시 대체 메시지 표시
    if (minimapContent.children.length === 0) {
      console.log('🔄 미니맵 로드 대기 중 - 임시 메시지 표시');
      minimapContent.innerHTML = `
        <div style="
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: #333;
          text-align: center;
          padding: 10px;
          font-size: 12px;
          background: #f8f9fa;
          border: 2px solid #007AFF;
          border-radius: 6px;
        ">
          <div>
            <div style="font-size: 24px; margin-bottom: 8px;">🗺️</div>
            <div style="font-weight: bold; margin-bottom: 4px;">미니맵 로딩 중...</div>
            <div style="font-size: 10px; color: #666;">잠시만 기다려주세요</div>
          </div>
        </div>
      `;
    }
    
    // 미니맵 로드 확인 (더 빠른 확인)
    setTimeout(() => {
      console.log('🔍 미니맵 로드 상태 확인 중...');
      console.log('🔍 minimapContent 자식 요소 수:', minimapContent.children.length);
      console.log('🔍 minimapContent 크기:', minimapContent.offsetWidth, 'x', minimapContent.offsetHeight);
      
      if (minimapContent.children.length === 0) {
        console.warn('⚠️ 미니맵이 로드되지 않음 - 대체 메시지 표시');
        minimapContent.innerHTML = `
          <div style="
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333;
            text-align: center;
            padding: 10px;
            font-size: 12px;
            background: #f8f9fa;
            border: 2px solid #007AFF;
            border-radius: 6px;
          ">
            <div>
              <div style="font-size: 24px; margin-bottom: 8px;">🗺️</div>
              <div style="font-weight: bold; margin-bottom: 4px;">미니맵</div>
              <div style="font-size: 10px; color: #666;">클릭하여 이동</div>
            </div>
          </div>
        `;
        
        // 대체 미니맵 클릭 이벤트
        minimapContent.addEventListener('click', function() {
          console.log('🔄 대체 미니맵 클릭됨');
          showToast('미니맵을 클릭하여 다른 위치로 이동할 수 있습니다.', 'info');
        });
      } else {
        console.log('✅ 미니맵이 정상적으로 로드됨');
        console.log('🔍 미니맵 내용:', minimapContent.innerHTML.substring(0, 100) + '...');
      }
    }, 500);
    
    // 현재 위치 마커 (회전하는 녹색 점)
    const positionMarker = new naver.maps.Marker({
      position: position,
      map: ROADVIEW_MINIMAP,
      icon: {
        content: `
          <div style="
            width: 16px; 
            height: 16px; 
            background: #34C759; 
            border: 2px solid white; 
            border-radius: 50%; 
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transform: rotate(0deg);
          ">
            <div style="
              position: absolute;
              top: 2px;
              left: 50%;
              transform: translateX(-50%);
              width: 0;
              height: 0;
              border-left: 3px solid transparent;
              border-right: 3px solid transparent;
              border-bottom: 6px solid white;
            "></div>
          </div>
        `,
        anchor: new naver.maps.Point(8, 8)
      }
    });
    
    // 미니맵 클릭 이벤트 - 파노라마 이동
    naver.maps.Event.addListener(ROADVIEW_MINIMAP, 'click', function(e) {
      console.log('🔄 미니맵 클릭됨:', e.coord);
      
      // 클릭한 위치로 파노라마 이동
      if (ROADVIEW) {
        ROADVIEW.setPosition(e.coord);
        
        // 마커 위치 업데이트
        positionMarker.setPosition(e.coord);
        
        // 미니맵 중심 이동
        ROADVIEW_MINIMAP.setCenter(e.coord);
        
        // 위치 정보 업데이트 (간단한 좌표 표시)
        updateRoadviewLocationInfo(e.coord);
        
        console.log('✅ 파노라마가 새로운 위치로 이동했습니다:', e.coord);
        showToast('새로운 위치로 이동했습니다.', 'info');
      }
    });
    
    // 미니맵 줌 컨트롤 이벤트
    const zoomInBtn = document.querySelector('.minimap-zoom .zoom-in');
    const zoomOutBtn = document.querySelector('.minimap-zoom .zoom-out');
    
    if (zoomInBtn) {
      zoomInBtn.addEventListener('click', function() {
        const currentZoom = ROADVIEW_MINIMAP.getZoom();
        ROADVIEW_MINIMAP.setZoom(currentZoom + 1);
      });
    }
    
    if (zoomOutBtn) {
      zoomOutBtn.addEventListener('click', function() {
        const currentZoom = ROADVIEW_MINIMAP.getZoom();
        ROADVIEW_MINIMAP.setZoom(currentZoom - 1);
      });
    }
    
    // 미니맵 확장 버튼 이벤트
    const expandBtn = document.querySelector('.minimap-expand-btn');
    if (expandBtn) {
      expandBtn.addEventListener('click', function() {
        const minimap = document.getElementById('roadviewMiniMap');
        if (minimap) {
          minimap.classList.toggle('expanded');
        }
      });
    }
    

    
    // 파노라마 위치 변경 시 미니맵 동기화
    naver.maps.Event.addListener(ROADVIEW, 'position_changed', function() {
      const currentPosition = ROADVIEW.getPosition();
      ROADVIEW_MINIMAP.setCenter(currentPosition);
      positionMarker.setPosition(currentPosition);
      
      // 위치 정보 업데이트
      updateRoadviewLocationInfo(currentPosition);
      
      // 방향 업데이트 - 점 자체가 회전
      const pov = ROADVIEW.getPov();
      const rotation = pov.pan;
      positionMarker.setIcon({
        content: `
          <div style="
            width: 16px; 
            height: 16px; 
            background: #34C759; 
            border: 2px solid white; 
            border-radius: 50%; 
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transform: rotate(${rotation}deg);
          ">
            <div style="
              position: absolute;
              top: 2px;
              left: 50%;
              transform: translateX(-50%);
              width: 0;
              height: 0;
              border-left: 3px solid transparent;
              border-right: 3px solid transparent;
              border-bottom: 6px solid white;
            "></div>
          </div>
        `,
        anchor: new naver.maps.Point(8, 8)
      });
    });
    // 파노라마 POV 변경 시 방향 표시 업데이트 - 점 자체가 회전
    naver.maps.Event.addListener(ROADVIEW, 'pov_changed', function() {
      const pov = ROADVIEW.getPov();
      const rotation = pov.pan;
      positionMarker.setIcon({
        content: `
          <div style="
            width: 16px; 
            height: 16px; 
            background: #34C759; 
            border: 2px solid white; 
            border-radius: 50%; 
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transform: rotate(${rotation}deg);
          ">
            <div style="
              position: absolute;
              top: 2px;
              left: 50%;
              transform: translateX(-50%);
              width: 0;
              height: 0;
              border-left: 3px solid transparent;
              border-right: 3px solid transparent;
              border-bottom: 6px solid white;
            "></div>
          </div>
        `,
        anchor: new naver.maps.Point(8, 8)
      });
    });
    
    // 파노라마 로드 완료 이벤트
    naver.maps.Event.addListener(ROADVIEW, 'init', function() {
      console.log('✅ 파노라마 초기화 완료');
      
      // 파노라마 크기 재조정
      setTimeout(() => {
        if (ROADVIEW) {
          ROADVIEW.setSize(new naver.maps.Size(roadviewDiv.offsetWidth, roadviewDiv.offsetHeight));
          naver.maps.Event.trigger(ROADVIEW, 'resize');
        }
      }, 100);
    });
    
    // 파노라마 로드 타임아웃 (3초 후 체크)
    setTimeout(() => {
      if (ROADVIEW && roadviewDiv.children.length === 0) {
        console.warn('⚠️ 파노라마 로드 타임아웃 - 대체 메시지 표시');
        roadviewDiv.innerHTML = `
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: white;
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          ">
            <div style="font-size: 48px; margin-bottom: 20px;">🏙️</div>
            <h3>거리뷰를 사용할 수 없습니다</h3>
            <p>이 지역에서는 네이버 거리뷰 데이터가 제공되지 않습니다.</p>
            <p>다른 위치를 선택하거나 지도로 돌아가세요.</p>
            <button onclick="closePanorama()" style="
              margin-top: 20px;
              padding: 10px 20px;
              background: rgba(255,255,255,0.2);
              border: 1px solid rgba(255,255,255,0.3);
              color: white;
              border-radius: 5px;
              cursor: pointer;
            ">지도로 돌아가기</button>
          </div>
        `;
      }
    }, 3000);
    
    // 파노라마 에러 이벤트
    naver.maps.Event.addListener(ROADVIEW, 'error', function(error) {
      console.error('❌ 파노라마 에러:', error);
      showToast('이 지역에서는 거리뷰를 사용할 수 없습니다.', 'error');
      
      // 에러 시 대체 메시지 표시
      roadviewDiv.innerHTML = `
        <div style="
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: white;
          text-align: center;
          padding: 20px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        ">
          <div style="font-size: 48px; margin-bottom: 20px;">🏙️</div>
          <h3>거리뷰를 사용할 수 없습니다</h3>
          <p>이 지역에서는 네이버 거리뷰 데이터가 제공되지 않습니다.</p>
          <p>다른 위치를 선택하거나 지도로 돌아가세요.</p>
          <button onclick="closePanorama()" style="
            margin-top: 20px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 5px;
            cursor: pointer;
          ">지도로 돌아가기</button>
        </div>
      `;
    });
    
    // 컨테이너 표시 - 인라인 스타일 초기화 후 표시
    container.style.display = '';
    container.style.visibility = '';
    container.style.opacity = '';
    container.style.pointerEvents = '';
    container.classList.remove('hidden');
    
    // 컨테이너가 표시된 후 파노라마 크기 재조정
    setTimeout(() => {
      if (ROADVIEW && roadviewDiv) {
        const width = roadviewDiv.offsetWidth;
        const height = roadviewDiv.offsetHeight;
        console.log('🔄 파노라마 크기 재조정:', width, 'x', height);
        console.log('🔍 roadviewDiv 자식 요소 수:', roadviewDiv.children.length);
        console.log('🔍 roadviewDiv 내용:', roadviewDiv.innerHTML.substring(0, 200) + '...');
        
        ROADVIEW.setSize(new naver.maps.Size(width, height));
        naver.maps.Event.trigger(ROADVIEW, 'resize');
        
        // 파노라마가 로드되지 않은 경우 대체 메시지 표시
        if (roadviewDiv.children.length === 0) {
          console.warn('⚠️ 파노라마가 로드되지 않음 - 대체 메시지 표시');
          roadviewDiv.innerHTML = `
            <div style="
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              height: 100%;
              color: white;
              text-align: center;
              padding: 20px;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            ">
              <div style="font-size: 48px; margin-bottom: 20px;">🏙️</div>
              <h3>거리뷰를 사용할 수 없습니다</h3>
              <p>이 지역에서는 네이버 거리뷰 데이터가 제공되지 않습니다.</p>
              <p>다른 위치를 선택하거나 지도로 돌아가세요.</p>
              <button onclick="closePanorama()" style="
                margin-top: 20px;
                padding: 10px 20px;
                background: rgba(255,255,255,0.2);
                border: 1px solid rgba(255,255,255,0.3);
                color: white;
                border-radius: 5px;
                cursor: pointer;
              ">지도로 돌아가기</button>
            </div>
          `;
        }
      }
    }, 200);
    
    // 강제로 컨테이너 표시 상태 확인
    console.log('🔍 컨테이너 표시 상태:', !container.classList.contains('hidden'));
    
    console.log('✅ 파노라마가 열렸습니다.');
    showToast('거리뷰가 열렸습니다.', 'info');
    
  } catch (error) {
    console.error('❌ 파노라마 초기화 실패:', error);
    console.error('❌ 에러 상세:', error.message, error.stack);
    showToast('이 지역에서는 거리뷰를 사용할 수 없습니다.', 'error');
  }
}

// 로드뷰 위치 정보 업데이트
function updateRoadviewLocationInfo(position) {
  try {
    const roadNameEl = document.querySelector('.road-name');
    const addressEl = document.querySelector('.address');
    
    if (roadNameEl) {
      roadNameEl.textContent = `위치: ${position.lat().toFixed(6)}, ${position.lng().toFixed(6)}`;
    }
    
    if (addressEl) {
      addressEl.textContent = '클릭하여 이동 가능';
    }
  } catch (error) {
    console.error('❌ 위치 정보 업데이트 중 오류:', error);
  }
}

// 파노라마 닫기 (지도로 돌아가기)
function closePanorama() {
  console.log('🔄 closePanorama 함수 호출됨');
  try {
    const container = document.getElementById('roadviewContainer');
    console.log('🔍 roadviewContainer 찾음:', !!container);
    
    // ROADVIEW 객체 타입 확인 및 안전한 정리
    if (ROADVIEW) {
      console.log('🔄 ROADVIEW 정리 중...');
      console.log('🔍 ROADVIEW 타입:', typeof ROADVIEW);
      console.log('🔍 ROADVIEW 객체:', ROADVIEW);
      
      try {
        if (typeof ROADVIEW.setMap === 'function') {
          ROADVIEW.setMap(null);
        } else if (typeof ROADVIEW.destroy === 'function') {
          ROADVIEW.destroy();
        } else if (ROADVIEW.remove) {
          ROADVIEW.remove();
        }
      } catch (e) {
        console.warn('⚠️ ROADVIEW 정리 중 오류:', e);
      }
      ROADVIEW = null;
    }
    
    // ROADVIEW_MINIMAP 객체 타입 확인 및 안전한 정리
    if (ROADVIEW_MINIMAP) {
      console.log('🔄 ROADVIEW_MINIMAP 정리 중...');
      console.log('🔍 ROADVIEW_MINIMAP 타입:', typeof ROADVIEW_MINIMAP);
      
      try {
        if (typeof ROADVIEW_MINIMAP.setMap === 'function') {
          ROADVIEW_MINIMAP.setMap(null);
        } else if (typeof ROADVIEW_MINIMAP.destroy === 'function') {
          ROADVIEW_MINIMAP.destroy();
        }
      } catch (e) {
        console.warn('⚠️ ROADVIEW_MINIMAP 정리 중 오류:', e);
      }
      ROADVIEW_MINIMAP = null;
    }
    
    // 컨테이너 숨기기 - 여러 방법으로 강제 숨김
    if (container) {
      container.classList.add('hidden');
      container.style.display = 'none';
      container.style.visibility = 'hidden';
      container.style.opacity = '0';
      container.style.pointerEvents = 'none';
      console.log('✅ roadviewContainer 숨김 처리 완료');
      console.log('🔍 컨테이너 스타일:', container.style.display, container.style.visibility);
    } else {
      console.error('❌ roadviewContainer를 찾을 수 없습니다.');
    }
    
    // 지도 다시 초기화
    if (MAP) {
      naver.maps.Event.trigger(MAP, 'resize');
    }
    
    console.log('✅ 파노라마가 닫히고 지도로 돌아갔습니다.');
    showToast('지도로 돌아갔습니다.', 'info');
  } catch (error) {
    console.error('❌ 파노라마 닫기 중 오류:', error);
    showToast('닫기 중 오류가 발생했습니다.', 'error');
  }
}

// 위성지도 토글 (지적편집도는 네이버에서 지원하지 않음)
function toggleCadastralMap() {
  const cadastralBtn = document.getElementById('cadastralBtn');
  if (!cadastralBtn) return;
  
  try {
    if (cadastralBtn.classList.contains('active')) {
      // 위성지도 비활성화
      cadastralBtn.classList.remove('active');
      MAP.setMapTypeId(naver.maps.MapTypeId.NORMAL);
      showToast('일반지도로 변경되었습니다.', 'info');
    } else {
      // 위성지도 활성화
      cadastralBtn.classList.add('active');
      MAP.setMapTypeId(naver.maps.MapTypeId.SATELLITE);
      showToast('위성지도로 변경되었습니다.', 'info');
    }
  } catch (error) {
    console.error('❌ 위성지도 변경 중 오류:', error);
    cadastralBtn.classList.remove('active');
    MAP.setMapTypeId(naver.maps.MapTypeId.NORMAL);
    showToast('위성지도 변경 중 오류가 발생했습니다.', 'error');
  }
}

// 거리제기 토글
function toggleDistanceMeasure() {
  const distanceBtn = document.getElementById('distanceBtn');
  if (!distanceBtn) return;
  
  if (IS_DISTANCE_MODE) {
    // 거리제기 모드 비활성화
    IS_DISTANCE_MODE = false;
    distanceBtn.classList.remove('active');
    clearDistanceMeasure();
    showToast('거리제기 모드가 비활성화되었습니다.', 'info');
  } else {
    // 거리제기 모드 활성화
    IS_DISTANCE_MODE = true;
    distanceBtn.classList.add('active');
    showToast('거리제기 모드가 활성화되었습니다. 지도를 클릭하여 거리를 측정하세요.', 'info');
  }
}

// 거리제기 초기화
function clearDistanceMeasure() {
  DISTANCE_POINTS = [];
  
  // 폴리라인 제거
  if (DISTANCE_POLYLINE) {
    DISTANCE_POLYLINE.setMap(null);
    DISTANCE_POLYLINE = null;
  }
  
  // 정보창 제거
  if (DISTANCE_INFO_WINDOW) {
    DISTANCE_INFO_WINDOW.close();
    DISTANCE_INFO_WINDOW = null;
  }
  
  // 거리제기 관련 마커들 제거
  if (MAP._distanceMarkers) {
    MAP._distanceMarkers.forEach(marker => {
      marker.setMap(null);
    });
    MAP._distanceMarkers = [];
  }
  
  // 전역 마커 배열도 정리
  DISTANCE_MARKERS.forEach(marker => {
    marker.setMap(null);
  });
  DISTANCE_MARKERS = [];
  
  DISTANCE_LABELS.forEach(label => {
    label.setMap(null);
  });
  DISTANCE_LABELS = [];
}

// 거리제기 클릭 이벤트 처리
function handleDistanceClick(e) {
  if (!IS_DISTANCE_MODE) return;
  
  const coord = e.coord;
  DISTANCE_POINTS.push(coord);
  
  // 거리제기 마커 배열 초기화
  if (!MAP._distanceMarkers) {
    MAP._distanceMarkers = [];
  }
  
  // 클릭한 지점에 마커 표시
  const marker = new naver.maps.Marker({
    position: coord,
    map: MAP,
    icon: {
      content: `<div style="width: 8px; height: 8px; background: #FF3B30; border: 2px solid white; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>`,
      anchor: new naver.maps.Point(4, 4)
    }
  });
  
  // 마커에 번호 표시
  const label = new naver.maps.Marker({
    position: coord,
    map: MAP,
    icon: {
      content: `<div style="background: #FF3B30; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">${DISTANCE_POINTS.length}</div>`,
      anchor: new naver.maps.Point(10, 10)
    }
  });
  
  // 마커들을 배열에 저장
  MAP._distanceMarkers.push(marker, label);
  DISTANCE_MARKERS.push(marker, label);
  
  // 두 점 이상이면 선 그리기
  if (DISTANCE_POINTS.length >= 2) {
    if (DISTANCE_POLYLINE) {
      DISTANCE_POLYLINE.setMap(null);
    }
    
    DISTANCE_POLYLINE = new naver.maps.Polyline({
      path: DISTANCE_POINTS,
      strokeColor: '#FF3B30',
      strokeWeight: 3,
      strokeOpacity: 0.8,
      map: MAP
    });
    
    // 총 거리 계산 및 정보창 표시
    updateDistanceInfo();
  }
}

// 거리 정보 업데이트 및 표시
function updateDistanceInfo() {
  if (DISTANCE_POINTS.length < 2) return;
  
  let totalDistance = 0;
  let segmentDistances = [];
  
  for (let i = 1; i < DISTANCE_POINTS.length; i++) {
    const segmentDistance = getDistanceMeters(DISTANCE_POINTS[i-1], DISTANCE_POINTS[i]);
    totalDistance += segmentDistance;
    segmentDistances.push(segmentDistance);
  }
  
  // 기존 정보창 제거
  if (DISTANCE_INFO_WINDOW) {
    DISTANCE_INFO_WINDOW.close();
  }
  
  // 새로운 정보창 생성
  const infoContent = `
    <div style="padding: 10px; min-width: 200px;">
      <h4 style="margin: 0 0 8px 0; color: #FF3B30;">📏 거리 측정 결과</h4>
      <div style="font-size: 12px; line-height: 1.4;">
        <div><strong>총 거리:</strong> ${(totalDistance / 1000).toFixed(2)}km</div>
        <div><strong>측정 지점:</strong> ${DISTANCE_POINTS.length}개</div>
        ${segmentDistances.map((dist, idx) => 
          `<div style="color: #666;">${idx + 1}→${idx + 2}: ${(dist / 1000).toFixed(2)}km</div>`
        ).join('')}
      </div>
      <div style="margin-top: 8px; font-size: 11px; color: #999;">
        우클릭으로 삭제 가능
      </div>
    </div>
  `;
  
  // 마지막 지점에 정보창 표시
  const lastPoint = DISTANCE_POINTS[DISTANCE_POINTS.length - 1];
  DISTANCE_INFO_WINDOW = new naver.maps.InfoWindow({
    content: infoContent,
    position: lastPoint,
    maxWidth: 250,
    backgroundColor: "#fff",
    borderColor: "#FF3B30",
    borderWidth: 2,
    anchorSize: new naver.maps.Size(10, 10),
    anchorColor: "#fff",
    pixelOffset: new naver.maps.Point(0, -10)
  });
  
  DISTANCE_INFO_WINDOW.open(MAP);
  
  showToast(`총 거리: ${(totalDistance / 1000).toFixed(2)}km (${DISTANCE_POINTS.length}개 지점)`, 'info');
}

// 거리제기 더블클릭 이벤트 처리 (측정 완료)
function handleDistanceDoubleClick(e) {
  if (!IS_DISTANCE_MODE) return;
  
  e.preventDefault();
  
  if (DISTANCE_POINTS.length >= 2) {
    let totalDistance = 0;
    for (let i = 1; i < DISTANCE_POINTS.length; i++) {
      totalDistance += getDistanceMeters(DISTANCE_POINTS[i-1], DISTANCE_POINTS[i]);
    }
    
    showToast(`측정 완료! 총 거리: ${(totalDistance / 1000).toFixed(2)}km`, 'success');
    toggleDistanceMeasure(); // 모드 해제
  }
}

// 거리제기 우클릭 이벤트 처리 (삭제)
function handleDistanceRightClick(e) {
  if (!IS_DISTANCE_MODE || DISTANCE_POINTS.length === 0) return;
  
  // 네이버 지도 API 이벤트 객체 구조에 맞게 처리
  try {
    if (e.preventDefault && typeof e.preventDefault === 'function') {
      e.preventDefault();
    }
  } catch (error) {
    console.log('⚠️ preventDefault 호출 실패 (무시됨):', error);
  }
  
  if (confirm('현재 측정된 거리를 삭제하시겠습니까?')) {
    clearDistanceMeasure();
    showToast('거리 측정이 삭제되었습니다.', 'info');
  }
}